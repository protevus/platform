/*
 * This file is part of the Protevus Platform.
 *
 * (C) Protevus <developers@protevus.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

import 'dart:async';
import 'dart:io';
import 'dart:isolate';

import 'package:protevus_application/application.dart';
import 'package:protevus_openapi/v3.dart';
import 'package:protevus_runtime/runtime.dart';
import 'package:logging/logging.dart';

export 'application_server.dart';
export 'options.dart';
export 'starter.dart';

/// The Application class is responsible for starting and managing instances of an ApplicationChannel.
///
/// An application object opens HTTP listeners that forward requests to instances of your [ApplicationChannel].
/// It is unlikely that you need to use this class directly - the `conduit serve` command creates an application object
/// on your behalf.
class Application<T extends ApplicationChannel> {
  /// A list of isolates that this application supervises.
  ///
  /// This list contains [ApplicationIsolateSupervisor] instances, each representing
  /// an isolate running a separate instance of the application. These supervisors
  /// are responsible for managing the lifecycle and communication with their
  /// respective isolates. The list is populated when the application starts and
  /// is cleared when the application stops.
  List<ApplicationIsolateSupervisor> supervisors = [];

  /// The [ApplicationServer] listening for HTTP requests while under test.
  ///
  /// This property is only valid when an application is started via [startOnCurrentIsolate].
  /// It represents the server instance that handles incoming HTTP requests during testing.
  /// The server is initialized when the application starts on the current isolate and
  /// provides access to the underlying HTTP server and application channel.
  ///
  /// Note: This property should not be accessed before calling [startOnCurrentIsolate],
  /// as it will not be initialized until then.
  late ApplicationServer server;

  /// The [ApplicationChannel] handling requests while under test.
  ///
  /// This property provides access to the application channel instance when the application
  /// is started using [startOnCurrentIsolate]. It allows direct interaction with the channel
  /// during testing, enabling access to its properties and methods.
  ///
  /// The returned value is cast to type [T], which should match the generic type parameter
  /// of the [Application] class.
  ///
  /// This property is only valid and accessible after calling [startOnCurrentIsolate].
  /// Attempting to access it before starting the application or when using [start] instead
  /// of [startOnCurrentIsolate] may result in unexpected behavior or errors.
  ///
  /// Usage example:
  /// ```dart
  /// final app = Application<MyChannel>();
  /// await app.startOnCurrentIsolate();
  /// final myChannel = app.channel;
  /// // Now you can interact with myChannel for testing purposes
  /// ```
  T get channel => server.channel as T;

  /// The logger that this application will write messages to.
  ///
  /// This logger is used throughout the application to record messages, errors,
  /// and other important information. It is configured with the name 'protevus',
  /// which will appear as the source of all log messages generated by this logger.
  ///
  /// The Logger class is likely from a logging package, providing various methods
  /// for different log levels (e.g., info, warning, error) and potentially
  /// supporting different output destinations or formatting options.
  ///
  /// Usage of this logger helps in debugging, monitoring, and maintaining the
  /// application by providing a centralized way to capture and analyze runtime
  /// information.
  Logger logger = Logger("protevus");

  /// The options used to configure this application.
  ///
  /// This property holds an instance of [ApplicationOptions] that contains various
  /// configuration settings for the application. These options can include things
  /// like port numbers, database configurations, or any other application-specific
  /// settings.
  ///
  /// The options are typically set before the application is started. It's important
  /// to note that modifying these options after the application has been started
  /// will not have any effect on the running application.
  ///
  /// Example usage:
  /// ```dart
  /// final app = Application<MyChannel>();
  /// app.options.port = 8080;
  /// app.options.configurationFilePath = 'config.yaml';
  /// await app.start();
  /// ```
  ///
  /// Default value is an instance of [ApplicationOptions] with default settings.
  ApplicationOptions options = ApplicationOptions();

  /// The duration to wait for each isolate during startup before failing.
  ///
  /// This property sets the maximum time allowed for each isolate to start up
  /// during the application's initialization process. If an isolate fails to
  /// complete its startup within this time frame, a [TimeoutException] is thrown.
  ///
  /// Defaults to 30 seconds.
  Duration isolateStartupTimeout = const Duration(seconds: 30);

  /// Indicates whether the application is currently running.
  ///
  /// This will return true if [start]/[startOnCurrentIsolate] have been invoked and completed; i.e. this is the synchronous version of the [Future] returned by [start]/[startOnCurrentIsolate].
  ///
  /// This value will return to false after [stop] has completed.
  bool get isRunning => _hasFinishedLaunching;

  /// Indicates whether the application has finished launching.
  ///
  /// This boolean flag is set to true once the application has successfully
  /// completed its startup process, including initializing all isolates and
  /// opening HTTP listeners. It is used internally to track the application's
  /// running state and is consulted by the [isRunning] getter.
  ///
  /// The value is set to false initially and when the application is stopped,
  /// and set to true at the end of successful [start] or [startOnCurrentIsolate]
  /// method execution.
  bool _hasFinishedLaunching = false;

  /// Retrieves the [ChannelRuntime] for the current application channel type.
  ///
  /// This getter accesses the [RuntimeContext.current] map using the generic type [T]
  /// (which represents the application's channel type) as the key. It then casts
  /// the retrieved value to [ChannelRuntime].
  ///
  /// The [ChannelRuntime] object contains runtime information and utilities
  /// specific to the channel type, which are used in various parts of the
  /// application for setup, initialization, and execution.
  ///
  /// This getter is used internally by the Application class to access
  /// channel-specific runtime information without exposing it publicly.
  ChannelRuntime get _runtime => RuntimeContext.current[T] as ChannelRuntime;

  /// Starts this application, allowing it to handle HTTP requests.
  ///
  /// This method initializes the application by spawning a specified number of isolates,
  /// each running an instance of the application channel. It then sets up an HTTP listener
  /// to distribute incoming requests across these isolates.
  ///
  /// The [Future] returned from this method will complete once all isolates have successfully started
  /// and are available to handle requests.
  ///
  /// If your application channel implements [ApplicationChannel.initializeApplication],
  /// it will be invoked prior to any isolate being spawned.
  ///
  /// See also [startOnCurrentIsolate] for starting an application when running automated tests.
  Future start({int numberOfInstances = 1, bool consoleLogging = false}) async {
    if (supervisors.isNotEmpty) {
      throw StateError(
        "Application error. Cannot invoke 'start' on already running Conduit application.",
      );
    }

    if (options.address == null) {
      if (options.isIpv6Only) {
        options.address = InternetAddress.anyIPv6;
      } else {
        options.address = InternetAddress.anyIPv4;
      }
    }

    try {
      await _runtime.runGlobalInitialization(options);

      for (var i = 0; i < numberOfInstances; i++) {
        final supervisor = await _spawn(
          this,
          options,
          i + 1,
          logger,
          isolateStartupTimeout,
          logToConsole: consoleLogging,
        );
        supervisors.add(supervisor);
        await supervisor.resume();
      }
    } catch (e, st) {
      logger.severe("$e", this, st);
      await stop().timeout(const Duration(seconds: 5));
      rethrow;
    }
    for (final sup in supervisors) {
      sup.sendPendingMessages();
    }
    _hasFinishedLaunching = true;
  }

  /// Starts the application on the current isolate without spawning additional isolates.
  ///
  /// An application started in this way will run on the same isolate this method is invoked on.
  /// Performance is limited when running the application with this method; prefer to use [start].
  Future startOnCurrentIsolate() async {
    if (supervisors.isNotEmpty) {
      throw StateError(
        "Application error. Cannot invoke 'test' on already running Conduit application.",
      );
    }

    options.address ??= InternetAddress.loopbackIPv4;

    try {
      await _runtime.runGlobalInitialization(options);

      server = ApplicationServer(_runtime.channelType, options, 1);

      await server.start();
      _hasFinishedLaunching = true;
    } catch (e, st) {
      logger.severe("$e", this, st);
      await stop().timeout(const Duration(seconds: 5));
      rethrow;
    }
  }

  /// Stops the application from running.
  ///
  /// This method performs the following actions:
  /// 1. Sets the '_hasFinishedLaunching' flag to false.
  /// 2. Stops all supervisor isolates concurrently.
  /// 3. Handles potential errors during supervisor shutdown, particularly checking for 'LateError'.
  /// 4. Attempts to close the server forcefully.
  /// 5. Logs any errors that occur during server closure.
  /// 6. Resets the '_hasFinishedLaunching' flag and clears the supervisors list.
  /// 7. Removes all listeners from the logger.
  ///
  /// If a 'LateError' is encountered during supervisor shutdown, it throws a [StateError]
  /// indicating that the channel type was not properly loaded.
  ///
  /// This method ensures a clean shutdown of all application components and should be
  /// called when the application needs to be terminated.
  Future stop() async {
    _hasFinishedLaunching = false;
    await Future.wait(supervisors.map((s) => s.stop()))
        .onError((error, stackTrace) {
      if (error.runtimeType.toString() == 'LateError') {
        throw StateError(
          'Channel type $T was not loaded in the current isolate. Check that the class was declared and public.',
        );
      }
      throw error! as Error;
    });

    try {
      await server.server.close(force: true);
    } catch (e) {
      logger.severe(e);
    }

    _hasFinishedLaunching = false;
    supervisors = [];

    logger.clearListeners();
  }

  /// Creates an [APIDocument] from an [ApplicationChannel].
  ///
  /// This static method generates API documentation for a given application channel type.
  /// It is primarily used by the 'conduit document' CLI command to create OpenAPI (formerly Swagger) documentation.
  ///
  /// The method performs the following steps:
  /// 1. Retrieves the runtime context for the specified channel type.
  /// 2. Runs global initialization with the provided configuration.
  /// 3. Creates an ApplicationServer instance.
  /// 4. Prepares the channel.
  /// 5. Generates the API documentation.
  /// 6. Closes the channel.
  /// 7. Returns the generated APIDocument.
  ///
  /// Parameters:
  /// - [type]: The Type of the ApplicationChannel subclass.
  /// - [config]: The ApplicationOptions containing configuration for the application.
  /// - [projectSpec]: A Map containing additional project-specific information for the documentation.
  ///
  /// Returns:
  /// A Future that resolves to an [APIDocument] containing the generated API documentation.
  ///
  /// This method is called by the `conduit document` CLI.
  static Future<APIDocument> document(
    Type type,
    ApplicationOptions config,
    Map<String, dynamic> projectSpec,
  ) async {
    final runtime = RuntimeContext.current[type] as ChannelRuntime;

    await runtime.runGlobalInitialization(config);

    final server = ApplicationServer(runtime.channelType, config, 1);

    await server.channel.prepare();

    final doc = await server.channel.documentAPI(projectSpec);

    await server.channel.close();

    return doc;
  }

  /// Spawns a new isolate to run an instance of the application.
  ///
  /// This method creates a new isolate that runs an instance of the application channel.
  /// It sets up the necessary communication channels and initializes the isolate with
  /// the application's configuration and runtime information.
  ///
  /// Parameters:
  /// - [application]: The main Application instance.
  /// - [config]: ApplicationOptions containing the configuration for this instance.
  /// - [identifier]: A unique identifier for this isolate.
  /// - [logger]: The Logger instance for logging.
  /// - [startupTimeout]: The maximum duration allowed for the isolate to start up.
  /// - [logToConsole]: Whether to enable console logging for this isolate (default: false).
  ///
  /// Returns:
  /// A Future that resolves to an [ApplicationIsolateSupervisor] managing the new isolate.
  ///
  /// This method is crucial for scaling the application across multiple isolates,
  /// allowing for better performance and resource utilization.
  Future<ApplicationIsolateSupervisor> _spawn(
    Application application,
    ApplicationOptions config,
    int identifier,
    Logger logger,
    Duration startupTimeout, {
    bool logToConsole = false,
  }) async {
    final receivePort = ReceivePort();

    final libraryUri = _runtime.libraryUri;
    final typeName = _runtime.name;
    final entryPoint = _runtime.isolateEntryPoint;

    final initialMessage = ApplicationInitialServerMessage(
      typeName,
      libraryUri,
      config,
      identifier,
      receivePort.sendPort,
      logToConsole: logToConsole,
    );
    final isolate =
        await Isolate.spawn(entryPoint, initialMessage, paused: true);

    return ApplicationIsolateSupervisor(
      application,
      isolate,
      receivePort,
      identifier,
      logger,
      startupTimeout: startupTimeout,
    );
  }
}

/// Represents an exception that occurs during the startup process of an application.
///
/// Contains the original exception that halted startup.
class ApplicationStartupException implements Exception {
  ApplicationStartupException(this.originalException);

  dynamic originalException;

  @override
  String toString() => originalException.toString();
}
