name: Descriptor
class_comment: null
dependencies:
- name: ClassExistenceResource
  type: class
  source: Symfony\Component\Config\Resource\ClassExistenceResource
- name: DescriptorInterface
  type: class
  source: Symfony\Component\Console\Descriptor\DescriptorInterface
- name: OutputInterface
  type: class
  source: Symfony\Component\Console\Output\OutputInterface
- name: Alias
  type: class
  source: Symfony\Component\DependencyInjection\Alias
- name: AnalyzeServiceReferencesPass
  type: class
  source: Symfony\Component\DependencyInjection\Compiler\AnalyzeServiceReferencesPass
- name: ServiceReferenceGraphEdge
  type: class
  source: Symfony\Component\DependencyInjection\Compiler\ServiceReferenceGraphEdge
- name: ContainerBuilder
  type: class
  source: Symfony\Component\DependencyInjection\ContainerBuilder
- name: ContainerInterface
  type: class
  source: Symfony\Component\DependencyInjection\ContainerInterface
- name: Definition
  type: class
  source: Symfony\Component\DependencyInjection\Definition
- name: InvalidArgumentException
  type: class
  source: Symfony\Component\DependencyInjection\Exception\InvalidArgumentException
- name: ParameterBag
  type: class
  source: Symfony\Component\DependencyInjection\ParameterBag\ParameterBag
- name: EventDispatcherInterface
  type: class
  source: Symfony\Component\EventDispatcher\EventDispatcherInterface
- name: Route
  type: class
  source: Symfony\Component\Routing\Route
- name: RouteCollection
  type: class
  source: Symfony\Component\Routing\RouteCollection
properties: []
methods:
- name: getReverseAliases
  visibility: protected
  parameters:
  - name: routes
  comment: "# * @author Jean-Fran\xE7ois Simon <jeanfrancois.simon@sensiolabs.com>\n\
    # *\n# * @internal\n# */\n# abstract class Descriptor implements DescriptorInterface\n\
    # {\n# protected OutputInterface $output;\n# \n# public function describe(OutputInterface\
    \ $output, mixed $object, array $options = []): void\n# {\n# $this->output = $output;\n\
    # \n# if ($object instanceof ContainerBuilder) {\n# (new AnalyzeServiceReferencesPass(false,\
    \ false))->process($object);\n# }\n# \n# $deprecatedParameters = [];\n# if ($object\
    \ instanceof ContainerBuilder && isset($options['parameter']) && ($parameterBag\
    \ = $object->getParameterBag()) instanceof ParameterBag) {\n# $deprecatedParameters\
    \ = $parameterBag->allDeprecated();\n# }\n# \n# match (true) {\n# $object instanceof\
    \ RouteCollection => $this->describeRouteCollection($object, $options),\n# $object\
    \ instanceof Route => $this->describeRoute($object, $options),\n# $object instanceof\
    \ ParameterBag => $this->describeContainerParameters($object, $options),\n# $object\
    \ instanceof ContainerBuilder && !empty($options['env-vars']) => $this->describeContainerEnvVars($this->getContainerEnvVars($object),\
    \ $options),\n# $object instanceof ContainerBuilder && isset($options['group_by'])\
    \ && 'tags' === $options['group_by'] => $this->describeContainerTags($object,\
    \ $options),\n# $object instanceof ContainerBuilder && isset($options['id']) =>\
    \ $this->describeContainerService($this->resolveServiceDefinition($object, $options['id']),\
    \ $options, $object),\n# $object instanceof ContainerBuilder && isset($options['parameter'])\
    \ => $this->describeContainerParameter($object->resolveEnvPlaceholders($object->getParameter($options['parameter'])),\
    \ $deprecatedParameters[$options['parameter']] ?? null, $options),\n# $object\
    \ instanceof ContainerBuilder && isset($options['deprecations']) => $this->describeContainerDeprecations($object,\
    \ $options),\n# $object instanceof ContainerBuilder => $this->describeContainerServices($object,\
    \ $options),\n# $object instanceof Definition => $this->describeContainerDefinition($object,\
    \ $options),\n# $object instanceof Alias => $this->describeContainerAlias($object,\
    \ $options),\n# $object instanceof EventDispatcherInterface => $this->describeEventDispatcherListeners($object,\
    \ $options),\n# \\is_callable($object) => $this->describeCallable($object, $options),\n\
    # default => throw new \\InvalidArgumentException(\\sprintf('Object of type \"\
    %s\" is not describable.', get_debug_type($object))),\n# };\n# \n# if ($object\
    \ instanceof ContainerBuilder) {\n# $object->getCompiler()->getServiceReferenceGraph()->clear();\n\
    # }\n# }\n# \n# protected function getOutput(): OutputInterface\n# {\n# return\
    \ $this->output;\n# }\n# \n# protected function write(string $content, bool $decorated\
    \ = false): void\n# {\n# $this->output->write($content, false, $decorated ? OutputInterface::OUTPUT_NORMAL\
    \ : OutputInterface::OUTPUT_RAW);\n# }\n# \n# abstract protected function describeRouteCollection(RouteCollection\
    \ $routes, array $options = []): void;\n# \n# abstract protected function describeRoute(Route\
    \ $route, array $options = []): void;\n# \n# abstract protected function describeContainerParameters(ParameterBag\
    \ $parameters, array $options = []): void;\n# \n# abstract protected function\
    \ describeContainerTags(ContainerBuilder $container, array $options = []): void;\n\
    # \n# /**\n# * Describes a container service by its name.\n# *\n# * Common options\
    \ are:\n# * * name: name of described service\n# *\n# * @param Definition|Alias|object\
    \ $service\n# */\n# abstract protected function describeContainerService(object\
    \ $service, array $options = [], ?ContainerBuilder $container = null): void;\n\
    # \n# /**\n# * Describes container services.\n# *\n# * Common options are:\n#\
    \ * * tag: filters described services by given tag\n# */\n# abstract protected\
    \ function describeContainerServices(ContainerBuilder $container, array $options\
    \ = []): void;\n# \n# abstract protected function describeContainerDeprecations(ContainerBuilder\
    \ $container, array $options = []): void;\n# \n# abstract protected function describeContainerDefinition(Definition\
    \ $definition, array $options = [], ?ContainerBuilder $container = null): void;\n\
    # \n# abstract protected function describeContainerAlias(Alias $alias, array $options\
    \ = [], ?ContainerBuilder $container = null): void;\n# \n# abstract protected\
    \ function describeContainerParameter(mixed $parameter, ?array $deprecation, array\
    \ $options = []): void;\n# \n# abstract protected function describeContainerEnvVars(array\
    \ $envs, array $options = []): void;\n# \n# /**\n# * Describes event dispatcher\
    \ listeners.\n# *\n# * Common options are:\n# * * name: name of listened event\n\
    # */\n# abstract protected function describeEventDispatcherListeners(EventDispatcherInterface\
    \ $eventDispatcher, array $options = []): void;\n# \n# abstract protected function\
    \ describeCallable(mixed $callable, array $options = []): void;\n# \n# protected\
    \ function formatValue(mixed $value): string\n# {\n# if ($value instanceof \\\
    UnitEnum) {\n# return ltrim(var_export($value, true), '\\\\');\n# }\n# \n# if\
    \ (\\is_object($value)) {\n# return \\sprintf('object(%s)', $value::class);\n\
    # }\n# \n# if (\\is_string($value)) {\n# return $value;\n# }\n# \n# return preg_replace(\"\
    /\\n\\s*/s\", '', var_export($value, true));\n# }\n# \n# protected function formatParameter(mixed\
    \ $value): string\n# {\n# if ($value instanceof \\UnitEnum) {\n# return ltrim(var_export($value,\
    \ true), '\\\\');\n# }\n# \n# // Recursively search for enum values, so we can\
    \ replace it\n# // before json_encode (which will not display anything for \\\
    UnitEnum otherwise)\n# if (\\is_array($value)) {\n# array_walk_recursive($value,\
    \ static function (&$value) {\n# if ($value instanceof \\UnitEnum) {\n# $value\
    \ = ltrim(var_export($value, true), '\\\\');\n# }\n# });\n# }\n# \n# if (\\is_bool($value)\
    \ || \\is_array($value) || (null === $value)) {\n# $jsonString = json_encode($value);\n\
    # \n# if (preg_match('/^(.{60})./us', $jsonString, $matches)) {\n# return $matches[1].'...';\n\
    # }\n# \n# return $jsonString;\n# }\n# \n# return (string) $value;\n# }\n# \n\
    # protected function resolveServiceDefinition(ContainerBuilder $container, string\
    \ $serviceId): mixed\n# {\n# if ($container->hasDefinition($serviceId)) {\n# return\
    \ $container->getDefinition($serviceId);\n# }\n# \n# // Some service IDs don't\
    \ have a Definition, they're aliases\n# if ($container->hasAlias($serviceId))\
    \ {\n# return $container->getAlias($serviceId);\n# }\n# \n# if ('service_container'\
    \ === $serviceId) {\n# return (new Definition(ContainerInterface::class))->setPublic(true)->setSynthetic(true);\n\
    # }\n# \n# // the service has been injected in some special way, just return the\
    \ service\n# return $container->get($serviceId);\n# }\n# \n# protected function\
    \ findDefinitionsByTag(ContainerBuilder $container, bool $showHidden): array\n\
    # {\n# $definitions = [];\n# $tags = $container->findTags();\n# asort($tags);\n\
    # \n# foreach ($tags as $tag) {\n# foreach ($container->findTaggedServiceIds($tag)\
    \ as $serviceId => $attributes) {\n# $definition = $this->resolveServiceDefinition($container,\
    \ $serviceId);\n# \n# if ($showHidden xor '.' === ($serviceId[0] ?? null)) {\n\
    # continue;\n# }\n# \n# if (!isset($definitions[$tag])) {\n# $definitions[$tag]\
    \ = [];\n# }\n# \n# $definitions[$tag][$serviceId] = $definition;\n# }\n# }\n\
    # \n# return $definitions;\n# }\n# \n# protected function sortParameters(ParameterBag\
    \ $parameters): array\n# {\n# $parameters = $parameters->all();\n# ksort($parameters);\n\
    # \n# return $parameters;\n# }\n# \n# protected function sortServiceIds(array\
    \ $serviceIds): array\n# {\n# asort($serviceIds);\n# \n# return $serviceIds;\n\
    # }\n# \n# protected function sortTaggedServicesByPriority(array $services): array\n\
    # {\n# $maxPriority = [];\n# foreach ($services as $service => $tags) {\n# $maxPriority[$service]\
    \ = \\PHP_INT_MIN;\n# foreach ($tags as $tag) {\n# $currentPriority = $tag['priority']\
    \ ?? 0;\n# if ($maxPriority[$service] < $currentPriority) {\n# $maxPriority[$service]\
    \ = $currentPriority;\n# }\n# }\n# }\n# uasort($maxPriority, fn ($a, $b) => $b\
    \ <=> $a);\n# \n# return array_keys($maxPriority);\n# }\n# \n# protected function\
    \ sortTagsByPriority(array $tags): array\n# {\n# $sortedTags = [];\n# foreach\
    \ ($tags as $tagName => $tag) {\n# $sortedTags[$tagName] = $this->sortByPriority($tag);\n\
    # }\n# \n# return $sortedTags;\n# }\n# \n# protected function sortByPriority(array\
    \ $tag): array\n# {\n# usort($tag, fn ($a, $b) => ($b['priority'] ?? 0) <=> ($a['priority']\
    \ ?? 0));\n# \n# return $tag;\n# }\n# \n# /**\n# * @return array<string, string[]>"
- name: getClassDescription
  visibility: public
  parameters:
  - name: class
  - name: '&$resolvedClass'
    default: 'null'
  comment: null
- name: getContainerEnvVars
  visibility: private
  parameters:
  - name: container
  comment: null
- name: getServiceEdges
  visibility: protected
  parameters:
  - name: container
  - name: serviceId
  comment: null
traits:
- Symfony\Component\Config\Resource\ClassExistenceResource
- Symfony\Component\Console\Descriptor\DescriptorInterface
- Symfony\Component\Console\Output\OutputInterface
- Symfony\Component\DependencyInjection\Alias
- Symfony\Component\DependencyInjection\Compiler\AnalyzeServiceReferencesPass
- Symfony\Component\DependencyInjection\Compiler\ServiceReferenceGraphEdge
- Symfony\Component\DependencyInjection\ContainerBuilder
- Symfony\Component\DependencyInjection\ContainerInterface
- Symfony\Component\DependencyInjection\Definition
- Symfony\Component\DependencyInjection\Exception\InvalidArgumentException
- Symfony\Component\DependencyInjection\ParameterBag\ParameterBag
- Symfony\Component\EventDispatcher\EventDispatcherInterface
- Symfony\Component\Routing\Route
- Symfony\Component\Routing\RouteCollection
interfaces:
- DescriptorInterface
