name: SessionStorageInterface
class_comment: null
dependencies:
- name: SessionBagInterface
  type: class
  source: Symfony\Component\HttpFoundation\Session\SessionBagInterface
properties: []
methods:
- name: start
  visibility: public
  parameters: []
  comment: '# * StorageInterface.

    # *

    # * @author Fabien Potencier <fabien@symfony.com>

    # * @author Drak <drak@zikula.org>

    # */

    # interface SessionStorageInterface

    # {

    # /**

    # * Starts the session.

    # *

    # * @throws \RuntimeException if something goes wrong starting the session'
- name: isStarted
  visibility: public
  parameters: []
  comment: '# * Checks if the session is started.'
- name: getId
  visibility: public
  parameters: []
  comment: '# * Returns the session ID.'
- name: setId
  visibility: public
  parameters:
  - name: id
  comment: '# * Sets the session ID.'
- name: getName
  visibility: public
  parameters: []
  comment: '# * Returns the session name.'
- name: setName
  visibility: public
  parameters:
  - name: name
  comment: '# * Sets the session name.'
- name: regenerate
  visibility: public
  parameters:
  - name: destroy
    default: 'false'
  - name: lifetime
    default: 'null'
  comment: '# * Regenerates id that represents this storage.

    # *

    # * This method must invoke session_regenerate_id($destroy) unless

    # * this interface is used for a storage object designed for unit

    # * or functional testing where a real PHP session would interfere

    # * with testing.

    # *

    # * Note regenerate+destroy should not clear the session data in memory

    # * only delete the session data from persistent storage.

    # *

    # * Care: When regenerating the session ID no locking is involved in PHP''s

    # * session design. See https://bugs.php.net/61470 for a discussion.

    # * So you must make sure the regenerated session is saved BEFORE sending the

    # * headers with the new ID. Symfony''s HttpKernel offers a listener for this.

    # * See Symfony\Component\HttpKernel\EventListener\SaveSessionListener.

    # * Otherwise session data could get lost again for concurrent requests with the

    # * new ID. One result could be that you get logged out after just logging in.

    # *

    # * @param bool     $destroy  Destroy session when regenerating?

    # * @param int|null $lifetime Sets the cookie lifetime for the session cookie.
    A null value

    # *                           will leave the system settings unchanged, 0 sets
    the cookie

    # *                           to expire with browser session. Time is in seconds,
    and is

    # *                           not a Unix timestamp.

    # *

    # * @throws \RuntimeException If an error occurs while regenerating this storage'
- name: save
  visibility: public
  parameters: []
  comment: '# * Force the session to be saved and closed.

    # *

    # * This method must invoke session_write_close() unless this interface is

    # * used for a storage object design for unit or functional testing where

    # * a real PHP session would interfere with testing, in which case

    # * it should actually persist the session data if required.

    # *

    # * @throws \RuntimeException if the session is saved without being started, or
    if the session

    # *                           is already closed'
- name: clear
  visibility: public
  parameters: []
  comment: '# * Clear all session data in memory.'
- name: getBag
  visibility: public
  parameters:
  - name: name
  comment: '# * Gets a SessionBagInterface by name.

    # *

    # * @throws \InvalidArgumentException If the bag does not exist'
- name: registerBag
  visibility: public
  parameters:
  - name: bag
  comment: '# * Registers a SessionBagInterface for use.'
- name: getMetadataBag
  visibility: public
  parameters: []
  comment: null
traits:
- Symfony\Component\HttpFoundation\Session\SessionBagInterface
interfaces: []
