name: FileLoader
class_comment: null
dependencies:
- name: FileLocatorFileNotFoundException
  type: class
  source: Symfony\Component\Config\Exception\FileLocatorFileNotFoundException
- name: LoaderLoadException
  type: class
  source: Symfony\Component\Config\Exception\LoaderLoadException
- name: FileLocatorInterface
  type: class
  source: Symfony\Component\Config\FileLocatorInterface
- name: BaseFileLoader
  type: class
  source: Symfony\Component\Config\Loader\FileLoader
- name: Loader
  type: class
  source: Symfony\Component\Config\Loader\Loader
- name: GlobResource
  type: class
  source: Symfony\Component\Config\Resource\GlobResource
- name: Alias
  type: class
  source: Symfony\Component\DependencyInjection\Alias
- name: AsAlias
  type: class
  source: Symfony\Component\DependencyInjection\Attribute\AsAlias
- name: Exclude
  type: class
  source: Symfony\Component\DependencyInjection\Attribute\Exclude
- name: When
  type: class
  source: Symfony\Component\DependencyInjection\Attribute\When
- name: WhenNot
  type: class
  source: Symfony\Component\DependencyInjection\Attribute\WhenNot
- name: ChildDefinition
  type: class
  source: Symfony\Component\DependencyInjection\ChildDefinition
- name: RegisterAutoconfigureAttributesPass
  type: class
  source: Symfony\Component\DependencyInjection\Compiler\RegisterAutoconfigureAttributesPass
- name: ContainerBuilder
  type: class
  source: Symfony\Component\DependencyInjection\ContainerBuilder
- name: Definition
  type: class
  source: Symfony\Component\DependencyInjection\Definition
- name: InvalidArgumentException
  type: class
  source: Symfony\Component\DependencyInjection\Exception\InvalidArgumentException
- name: LogicException
  type: class
  source: Symfony\Component\DependencyInjection\Exception\LogicException
properties: []
methods:
- name: __construct
  visibility: public
  parameters:
  - name: container
  - name: locator
  - name: env
    default: 'null'
  - name: prepend
    default: 'false'
  comment: "# * FileLoader is the abstract class used by all built-in loaders that\
    \ are file based.\n# *\n# * @author Fabien Potencier <fabien@symfony.com>\n# */\n\
    # abstract class FileLoader extends BaseFileLoader\n# {\n# public const ANONYMOUS_ID_REGEXP\
    \ = '/^\\.\\d+_[^~]*+~[._a-zA-Z\\d]{7}$/';\n# \n# protected bool $isLoadingInstanceof\
    \ = false;\n# protected array $instanceof = [];\n# protected array $interfaces\
    \ = [];\n# protected array $singlyImplemented = [];\n# /** @var array<string,\
    \ Alias> */\n# protected array $aliases = [];\n# protected bool $autoRegisterAliasesForSinglyImplementedInterfaces\
    \ = true;\n# protected array $extensionConfigs = [];\n# protected int $importing\
    \ = 0;\n# \n# /**\n# * @param bool $prepend Whether to prepend extension config\
    \ instead of appending them"
- name: import
  visibility: public
  parameters:
  - name: resource
  - name: type
    default: 'null'
  - name: ignoreErrors
    default: 'false'
  - name: sourceResource
    default: 'null'
  - name: exclude
    default: 'null'
  comment: '# * @param bool|string $ignoreErrors Whether errors should be ignored;
    pass "not_found" to ignore only when the loaded resource is not found'
- name: registerClasses
  visibility: public
  parameters:
  - name: prototype
  - name: namespace
  - name: resource
  - name: exclude
    default: 'null'
  - name: source
    default: 'null'
  comment: '# * Registers a set of classes as services using PSR-4 for discovery.

    # *

    # * @param Definition           $prototype A definition to use as template

    # * @param string               $namespace The namespace prefix of classes in
    the scanned directory

    # * @param string               $resource  The directory to look for classes,
    glob-patterns allowed

    # * @param string|string[]|null $exclude   A globbed path of files to exclude
    or an array of globbed paths of files to exclude

    # * @param string|null          $source    The path to the file that defines the
    auto-discovery rule'
- name: setDefinition
  visibility: protected
  parameters:
  - name: id
  - name: definition
  comment: "# @var AsAlias $attribute */\n# $attribute = $attr->newInstance();\n#\
    \ $alias = $attribute->id ?? $defaultAlias;\n# $public = $attribute->public;\n\
    # if (null === $alias) {\n# throw new LogicException(\\sprintf('Alias cannot be\
    \ automatically determined for class \"%s\". If you have used the #[AsAlias] attribute\
    \ with a class implementing multiple interfaces, add the interface you want to\
    \ alias to the first parameter of #[AsAlias].', $class));\n# }\n# if (isset($this->aliases[$alias]))\
    \ {\n# throw new LogicException(\\sprintf('The \"%s\" alias has already been defined\
    \ with the #[AsAlias] attribute in \"%s\".', $alias, $this->aliases[$alias]));\n\
    # }\n# $this->aliases[$alias] = new Alias($class, $public);\n# }\n# }\n# }\n#\
    \ \n# foreach ($this->aliases as $alias => $aliasDefinition) {\n# $this->container->setAlias($alias,\
    \ $aliasDefinition);\n# }\n# \n# if ($this->autoRegisterAliasesForSinglyImplementedInterfaces)\
    \ {\n# $this->registerAliasesForSinglyImplementedInterfaces();\n# }\n# }\n# \n\
    # public function registerAliasesForSinglyImplementedInterfaces(): void\n# {\n\
    # foreach ($this->interfaces as $interface) {\n# if (!empty($this->singlyImplemented[$interface])\
    \ && !isset($this->aliases[$interface]) && !$this->container->has($interface))\
    \ {\n# $this->container->setAlias($interface, $this->singlyImplemented[$interface]);\n\
    # }\n# }\n# \n# $this->interfaces = $this->singlyImplemented = $this->aliases\
    \ = [];\n# }\n# \n# final protected function loadExtensionConfig(string $namespace,\
    \ array $config): void\n# {\n# if (!$this->prepend) {\n# $this->container->loadFromExtension($namespace,\
    \ $config);\n# \n# return;\n# }\n# \n# if ($this->importing) {\n# if (!isset($this->extensionConfigs[$namespace]))\
    \ {\n# $this->extensionConfigs[$namespace] = [];\n# }\n# array_unshift($this->extensionConfigs[$namespace],\
    \ $config);\n# \n# return;\n# }\n# \n# $this->container->prependExtensionConfig($namespace,\
    \ $config);\n# }\n# \n# final protected function loadExtensionConfigs(): void\n\
    # {\n# if ($this->importing || !$this->extensionConfigs) {\n# return;\n# }\n#\
    \ \n# foreach ($this->extensionConfigs as $namespace => $configs) {\n# foreach\
    \ ($configs as $config) {\n# $this->container->prependExtensionConfig($namespace,\
    \ $config);\n# }\n# }\n# \n# $this->extensionConfigs = [];\n# }\n# \n# /**\n#\
    \ * Registers a definition in the container with its instanceof-conditionals."
- name: findClasses
  visibility: private
  parameters:
  - name: namespace
  - name: pattern
  - name: excludePatterns
  - name: autoconfigureAttributes
  - name: source
  comment: null
- name: addContainerExcludedTag
  visibility: private
  parameters:
  - name: class
  - name: source
  comment: null
traits:
- Symfony\Component\Config\Exception\FileLocatorFileNotFoundException
- Symfony\Component\Config\Exception\LoaderLoadException
- Symfony\Component\Config\FileLocatorInterface
- Symfony\Component\Config\Loader\Loader
- Symfony\Component\Config\Resource\GlobResource
- Symfony\Component\DependencyInjection\Alias
- Symfony\Component\DependencyInjection\Attribute\AsAlias
- Symfony\Component\DependencyInjection\Attribute\Exclude
- Symfony\Component\DependencyInjection\Attribute\When
- Symfony\Component\DependencyInjection\Attribute\WhenNot
- Symfony\Component\DependencyInjection\ChildDefinition
- Symfony\Component\DependencyInjection\Compiler\RegisterAutoconfigureAttributesPass
- Symfony\Component\DependencyInjection\ContainerBuilder
- Symfony\Component\DependencyInjection\Definition
- Symfony\Component\DependencyInjection\Exception\InvalidArgumentException
- Symfony\Component\DependencyInjection\Exception\LogicException
interfaces: []
