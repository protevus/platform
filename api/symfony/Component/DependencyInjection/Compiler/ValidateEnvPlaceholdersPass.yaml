name: ValidateEnvPlaceholdersPass
class_comment: '# * Validates environment variable placeholders used in extension
  configuration with dummy values.

  # *

  # * @author Roland Franssen <franssen.roland@gmail.com>'
dependencies:
- name: BaseNode
  type: class
  source: Symfony\Component\Config\Definition\BaseNode
- name: ConfigurationInterface
  type: class
  source: Symfony\Component\Config\Definition\ConfigurationInterface
- name: Processor
  type: class
  source: Symfony\Component\Config\Definition\Processor
- name: ContainerBuilder
  type: class
  source: Symfony\Component\DependencyInjection\ContainerBuilder
- name: ConfigurationExtensionInterface
  type: class
  source: Symfony\Component\DependencyInjection\Extension\ConfigurationExtensionInterface
- name: EnvPlaceholderParameterBag
  type: class
  source: Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag
- name: ParameterBag
  type: class
  source: Symfony\Component\DependencyInjection\ParameterBag\ParameterBag
properties: []
methods:
- name: getExtensionConfig
  visibility: public
  parameters: []
  comment: "# * Validates environment variable placeholders used in extension configuration\
    \ with dummy values.\n# *\n# * @author Roland Franssen <franssen.roland@gmail.com>\n\
    # */\n# class ValidateEnvPlaceholdersPass implements CompilerPassInterface\n#\
    \ {\n# private const TYPE_FIXTURES = ['array' => [], 'bool' => false, 'float'\
    \ => 0.0, 'int' => 0, 'string' => ''];\n# \n# private array $extensionConfig =\
    \ [];\n# \n# public function process(ContainerBuilder $container): void\n# {\n\
    # $this->extensionConfig = [];\n# \n# if (!class_exists(BaseNode::class) || !$extensions\
    \ = $container->getExtensions()) {\n# return;\n# }\n# \n# $resolvingBag = $container->getParameterBag();\n\
    # if (!$resolvingBag instanceof EnvPlaceholderParameterBag) {\n# return;\n# }\n\
    # \n# $defaultBag = new ParameterBag($resolvingBag->all());\n# $envTypes = $resolvingBag->getProvidedTypes();\n\
    # foreach ($resolvingBag->getEnvPlaceholders() + $resolvingBag->getUnusedEnvPlaceholders()\
    \ as $env => $placeholders) {\n# $values = [];\n# if (false === $i = strpos($env,\
    \ ':')) {\n# $default = $defaultBag->has(\"env($env)\") ? $defaultBag->get(\"\
    env($env)\") : self::TYPE_FIXTURES['string'];\n# $defaultType = null !== $default\
    \ ? get_debug_type($default) : 'string';\n# $values[$defaultType] = $default;\n\
    # } else {\n# $prefix = substr($env, 0, $i);\n# foreach ($envTypes[$prefix] ??\
    \ ['string'] as $type) {\n# $values[$type] = self::TYPE_FIXTURES[$type] ?? null;\n\
    # }\n# }\n# foreach ($placeholders as $placeholder) {\n# BaseNode::setPlaceholder($placeholder,\
    \ $values);\n# }\n# }\n# \n# $processor = new Processor();\n# \n# foreach ($extensions\
    \ as $name => $extension) {\n# if (!($extension instanceof ConfigurationExtensionInterface\
    \ || $extension instanceof ConfigurationInterface)\n# || !$config = array_filter($container->getExtensionConfig($name))\n\
    # ) {\n# // this extension has no semantic configuration or was not called\n#\
    \ continue;\n# }\n# \n# $config = $resolvingBag->resolveValue($config);\n# \n\
    # if ($extension instanceof ConfigurationInterface) {\n# $configuration = $extension;\n\
    # } elseif (null === $configuration = $extension->getConfiguration($config, $container))\
    \ {\n# continue;\n# }\n# \n# $this->extensionConfig[$name] = $processor->processConfiguration($configuration,\
    \ $config);\n# }\n# \n# $resolvingBag->clearUnusedEnvPlaceholders();\n# }\n# \n\
    # /**\n# * @internal"
traits:
- Symfony\Component\Config\Definition\BaseNode
- Symfony\Component\Config\Definition\ConfigurationInterface
- Symfony\Component\Config\Definition\Processor
- Symfony\Component\DependencyInjection\ContainerBuilder
- Symfony\Component\DependencyInjection\Extension\ConfigurationExtensionInterface
- Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag
- Symfony\Component\DependencyInjection\ParameterBag\ParameterBag
interfaces:
- CompilerPassInterface
