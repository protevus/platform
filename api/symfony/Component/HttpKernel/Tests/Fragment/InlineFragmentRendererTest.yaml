name: InlineFragmentRendererTest
class_comment: '# * @group time-sensitive'
dependencies:
- name: TestCase
  type: class
  source: PHPUnit\Framework\TestCase
- name: EventDispatcher
  type: class
  source: Symfony\Component\EventDispatcher\EventDispatcher
- name: Request
  type: class
  source: Symfony\Component\HttpFoundation\Request
- name: RequestStack
  type: class
  source: Symfony\Component\HttpFoundation\RequestStack
- name: Response
  type: class
  source: Symfony\Component\HttpFoundation\Response
- name: ArgumentResolverInterface
  type: class
  source: Symfony\Component\HttpKernel\Controller\ArgumentResolverInterface
- name: ControllerReference
  type: class
  source: Symfony\Component\HttpKernel\Controller\ControllerReference
- name: ControllerResolverInterface
  type: class
  source: Symfony\Component\HttpKernel\Controller\ControllerResolverInterface
- name: ExceptionEvent
  type: class
  source: Symfony\Component\HttpKernel\Event\ExceptionEvent
- name: InlineFragmentRenderer
  type: class
  source: Symfony\Component\HttpKernel\Fragment\InlineFragmentRenderer
- name: HttpKernel
  type: class
  source: Symfony\Component\HttpKernel\HttpKernel
- name: HttpKernelInterface
  type: class
  source: Symfony\Component\HttpKernel\HttpKernelInterface
- name: KernelEvents
  type: class
  source: Symfony\Component\HttpKernel\KernelEvents
- name: EventDispatcherInterface
  type: class
  source: Symfony\Contracts\EventDispatcher\EventDispatcherInterface
properties: []
methods:
- name: getKernelExpectingRequest
  visibility: private
  parameters:
  - name: expectedRequest
  comment: "# * @group time-sensitive\n# */\n# class InlineFragmentRendererTest extends\
    \ TestCase\n# {\n# public function testRender()\n# {\n# $strategy = new InlineFragmentRenderer($this->getKernel(new\
    \ Response('foo')));\n# \n# $this->assertEquals('foo', $strategy->render('/',\
    \ Request::create('/'))->getContent());\n# }\n# \n# public function testRenderWithControllerReference()\n\
    # {\n# $strategy = new InlineFragmentRenderer($this->getKernel(new Response('foo')));\n\
    # \n# $this->assertEquals('foo', $strategy->render(new ControllerReference('main_controller',\
    \ [], []), Request::create('/'))->getContent());\n# }\n# \n# public function testRenderWithObjectsAsAttributes()\n\
    # {\n# $object = new \\stdClass();\n# \n# $subRequest = Request::create('/_fragment?_path=_format%3Dhtml%26_locale%3Den%26_controller%3Dmain_controller');\n\
    # $subRequest->attributes->replace(['object' => $object, '_format' => 'html',\
    \ '_controller' => 'main_controller', '_locale' => 'en']);\n# $subRequest->headers->set('x-forwarded-for',\
    \ ['127.0.0.1']);\n# $subRequest->headers->set('forwarded', ['for=\"127.0.0.1\"\
    ;host=\"localhost\";proto=http']);\n# $subRequest->server->set('HTTP_X_FORWARDED_FOR',\
    \ '127.0.0.1');\n# $subRequest->server->set('HTTP_FORWARDED', 'for=\"127.0.0.1\"\
    ;host=\"localhost\";proto=http');\n# \n# $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($subRequest));\n\
    # \n# $this->assertSame('foo', $strategy->render(new ControllerReference('main_controller',\
    \ ['object' => $object], []), Request::create('/'))->getContent());\n# }\n# \n\
    # public function testRenderWithTrustedHeaderDisabled()\n# {\n# Request::setTrustedProxies([],\
    \ 0);\n# \n# $expectedSubRequest = Request::create('/');\n# $expectedSubRequest->headers->set('x-forwarded-for',\
    \ ['127.0.0.1']);\n# $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR',\
    \ '127.0.0.1');\n# \n# $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($expectedSubRequest));\n\
    # $this->assertSame('foo', $strategy->render('/', Request::create('/'))->getContent());\n\
    # \n# Request::setTrustedProxies([], -1);\n# }\n# \n# public function testRenderExceptionNoIgnoreErrors()\n\
    # {\n# $this->expectException(\\RuntimeException::class);\n# $dispatcher = $this->createMock(EventDispatcherInterface::class);\n\
    # $dispatcher->expects($this->never())->method('dispatch');\n# \n# $strategy =\
    \ new InlineFragmentRenderer($this->getKernel(new \\RuntimeException('foo')),\
    \ $dispatcher);\n# \n# $this->assertEquals('foo', $strategy->render('/', Request::create('/'))->getContent());\n\
    # }\n# \n# public function testRenderExceptionIgnoreErrors()\n# {\n# $exception\
    \ = new \\RuntimeException('foo');\n# $kernel = $this->getKernel($exception);\n\
    # $request = Request::create('/');\n# $expectedEvent = new ExceptionEvent($kernel,\
    \ $request, $kernel::SUB_REQUEST, $exception);\n# $dispatcher = $this->createMock(EventDispatcherInterface::class);\n\
    # $dispatcher->expects($this->once())->method('dispatch')->with($expectedEvent,\
    \ KernelEvents::EXCEPTION);\n# \n# $strategy = new InlineFragmentRenderer($kernel,\
    \ $dispatcher);\n# \n# $this->assertEmpty($strategy->render('/', $request, ['ignore_errors'\
    \ => true])->getContent());\n# }\n# \n# public function testRenderExceptionIgnoreErrorsWithAlt()\n\
    # {\n# $strategy = new InlineFragmentRenderer($this->getKernel(function () {\n\
    # static $firstCall = true;\n# \n# if ($firstCall) {\n# $firstCall = false;\n\
    # \n# throw new \\RuntimeException('foo');\n# }\n# \n# return new Response('bar');\n\
    # }));\n# \n# $this->assertEquals('bar', $strategy->render('/', Request::create('/'),\
    \ ['ignore_errors' => true, 'alt' => '/foo'])->getContent());\n# }\n# \n# private\
    \ function getKernel($returnValue)\n# {\n# $kernel = $this->createMock(HttpKernelInterface::class);\n\
    # $mocker = $kernel\n# ->expects($this->any())\n# ->method('handle')\n# ;\n# \n\
    # if ($returnValue instanceof \\Exception) {\n# $mocker->willThrowException($returnValue);\n\
    # } elseif ($returnValue instanceof \\Closure) {\n# $mocker->willReturnCallback($returnValue);\n\
    # } else {\n# $mocker->willReturn(...(\\is_array($returnValue) ? $returnValue\
    \ : [$returnValue]));\n# }\n# \n# return $kernel;\n# }\n# \n# public function\
    \ testExceptionInSubRequestsDoesNotMangleOutputBuffers()\n# {\n# $controllerResolver\
    \ = $this->createMock(ControllerResolverInterface::class);\n# $controllerResolver\n\
    # ->expects($this->once())\n# ->method('getController')\n# ->willReturn(function\
    \ () {\n# ob_start();\n# echo 'bar';\n# throw new \\RuntimeException();\n# })\n\
    # ;\n# \n# $argumentResolver = $this->createMock(ArgumentResolverInterface::class);\n\
    # $argumentResolver\n# ->expects($this->once())\n# ->method('getArguments')\n\
    # ->willReturn([])\n# ;\n# \n# $kernel = new HttpKernel(new EventDispatcher(),\
    \ $controllerResolver, new RequestStack(), $argumentResolver);\n# $renderer =\
    \ new InlineFragmentRenderer($kernel);\n# \n# // simulate a main request with\
    \ output buffering\n# ob_start();\n# echo 'Foo';\n# \n# // simulate a sub-request\
    \ with output buffering and an exception\n# $renderer->render('/', Request::create('/'),\
    \ ['ignore_errors' => true]);\n# \n# $this->assertEquals('Foo', ob_get_clean());\n\
    # }\n# \n# public function testLocaleAndFormatAreKeptInSubrequest()\n# {\n# $expectedSubRequest\
    \ = Request::create('/');\n# $expectedSubRequest->attributes->set('_format', 'foo');\n\
    # $expectedSubRequest->setLocale('fr');\n# if (Request::HEADER_X_FORWARDED_FOR\
    \ & Request::getTrustedHeaderSet()) {\n# $expectedSubRequest->headers->set('x-forwarded-for',\
    \ ['127.0.0.1']);\n# $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR',\
    \ '127.0.0.1');\n# }\n# $expectedSubRequest->headers->set('forwarded', ['for=\"\
    127.0.0.1\";host=\"localhost\";proto=http']);\n# $expectedSubRequest->server->set('HTTP_FORWARDED',\
    \ 'for=\"127.0.0.1\";host=\"localhost\";proto=http');\n# \n# $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($expectedSubRequest));\n\
    # \n# $request = Request::create('/');\n# $request->attributes->set('_format',\
    \ 'foo');\n# $request->setLocale('fr');\n# $strategy->render('/', $request);\n\
    # }\n# \n# public function testESIHeaderIsKeptInSubrequest()\n# {\n# $expectedSubRequest\
    \ = Request::create('/');\n# $expectedSubRequest->headers->set('Surrogate-Capability',\
    \ 'abc=\"ESI/1.0\"');\n# \n# if (Request::HEADER_X_FORWARDED_FOR & Request::getTrustedHeaderSet())\
    \ {\n# $expectedSubRequest->headers->set('x-forwarded-for', ['127.0.0.1']);\n\
    # $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR', '127.0.0.1');\n# }\n\
    # $expectedSubRequest->headers->set('forwarded', ['for=\"127.0.0.1\";host=\"localhost\"\
    ;proto=http']);\n# $expectedSubRequest->server->set('HTTP_FORWARDED', 'for=\"\
    127.0.0.1\";host=\"localhost\";proto=http');\n# \n# $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($expectedSubRequest));\n\
    # \n# $request = Request::create('/');\n# $request->headers->set('Surrogate-Capability',\
    \ 'abc=\"ESI/1.0\"');\n# $strategy->render('/', $request);\n# }\n# \n# public\
    \ function testESIHeaderIsKeptInSubrequestWithTrustedHeaderDisabled()\n# {\n#\
    \ Request::setTrustedProxies([], Request::HEADER_FORWARDED);\n# \n# $this->testESIHeaderIsKeptInSubrequest();\n\
    # \n# Request::setTrustedProxies([], -1);\n# }\n# \n# public function testHeadersPossiblyResultingIn304AreNotAssignedToSubrequest()\n\
    # {\n# $expectedSubRequest = Request::create('/');\n# $expectedSubRequest->headers->set('x-forwarded-for',\
    \ ['127.0.0.1']);\n# $expectedSubRequest->headers->set('forwarded', ['for=\"127.0.0.1\"\
    ;host=\"localhost\";proto=http']);\n# $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR',\
    \ '127.0.0.1');\n# $expectedSubRequest->server->set('HTTP_FORWARDED', 'for=\"\
    127.0.0.1\";host=\"localhost\";proto=http');\n# \n# $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($expectedSubRequest));\n\
    # $request = Request::create('/', 'GET', [], [], [], ['HTTP_IF_MODIFIED_SINCE'\
    \ => 'Fri, 01 Jan 2016 00:00:00 GMT', 'HTTP_IF_NONE_MATCH' => '*']);\n# $strategy->render('/',\
    \ $request);\n# }\n# \n# public function testFirstTrustedProxyIsSetAsRemote()\n\
    # {\n# Request::setTrustedProxies(['1.1.1.1'], -1);\n# \n# $expectedSubRequest\
    \ = Request::create('/');\n# $expectedSubRequest->headers->set('Surrogate-Capability',\
    \ 'abc=\"ESI/1.0\"');\n# $expectedSubRequest->server->set('REMOTE_ADDR', '127.0.0.1');\n\
    # $expectedSubRequest->headers->set('x-forwarded-for', ['127.0.0.1']);\n# $expectedSubRequest->headers->set('forwarded',\
    \ ['for=\"127.0.0.1\";host=\"localhost\";proto=http']);\n# $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR',\
    \ '127.0.0.1');\n# $expectedSubRequest->server->set('HTTP_FORWARDED', 'for=\"\
    127.0.0.1\";host=\"localhost\";proto=http');\n# \n# $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($expectedSubRequest));\n\
    # \n# $request = Request::create('/');\n# $request->headers->set('Surrogate-Capability',\
    \ 'abc=\"ESI/1.0\"');\n# $strategy->render('/', $request);\n# \n# Request::setTrustedProxies([],\
    \ -1);\n# }\n# \n# public function testIpAddressOfRangedTrustedProxyIsSetAsRemote()\n\
    # {\n# $expectedSubRequest = Request::create('/');\n# $expectedSubRequest->headers->set('Surrogate-Capability',\
    \ 'abc=\"ESI/1.0\"');\n# $expectedSubRequest->server->set('REMOTE_ADDR', '127.0.0.1');\n\
    # $expectedSubRequest->headers->set('x-forwarded-for', ['127.0.0.1']);\n# $expectedSubRequest->headers->set('forwarded',\
    \ ['for=\"127.0.0.1\";host=\"localhost\";proto=http']);\n# $expectedSubRequest->server->set('HTTP_X_FORWARDED_FOR',\
    \ '127.0.0.1');\n# $expectedSubRequest->server->set('HTTP_FORWARDED', 'for=\"\
    127.0.0.1\";host=\"localhost\";proto=http');\n# \n# Request::setTrustedProxies(['1.1.1.1/24'],\
    \ -1);\n# \n# $strategy = new InlineFragmentRenderer($this->getKernelExpectingRequest($expectedSubRequest));\n\
    # \n# $request = Request::create('/');\n# $request->headers->set('Surrogate-Capability',\
    \ 'abc=\"ESI/1.0\"');\n# $strategy->render('/', $request);\n# \n# Request::setTrustedProxies([],\
    \ -1);\n# }\n# \n# public function testStatelessAttributeIsForwardedByDefault()\n\
    # {\n# $request = Request::create('/');\n# $request->attributes->set('_stateless',\
    \ true);\n# \n# $kernel = $this->createMock(HttpKernelInterface::class);\n# $kernel\n\
    # ->expects($this->once())\n# ->method('handle')\n# ->with($this->callback(static\
    \ fn (Request $subRequest) => $subRequest->attributes->get('_stateless')))\n#\
    \ ;\n# $strategy = new InlineFragmentRenderer($kernel);\n# $strategy->render('/',\
    \ $request);\n# }\n# \n# public function testStatelessAttributeCanBeDisabled()\n\
    # {\n# $request = Request::create('/');\n# $request->attributes->set('_stateless',\
    \ true);\n# \n# $kernel = $this->createMock(HttpKernelInterface::class);\n# $kernel\n\
    # ->expects($this->once())\n# ->method('handle')\n# ->with($this->callback(static\
    \ fn (Request $subRequest) => !$subRequest->attributes->get('_stateless')))\n\
    # ;\n# $strategy = new InlineFragmentRenderer($kernel);\n# $strategy->render(new\
    \ ControllerReference('main_controller', ['_stateless' => false]), $request);\n\
    # }\n# \n# /**\n# * Creates a Kernel expecting a request equals to $request."
- name: getBar
  visibility: public
  parameters: []
  comment: null
traits:
- PHPUnit\Framework\TestCase
- Symfony\Component\EventDispatcher\EventDispatcher
- Symfony\Component\HttpFoundation\Request
- Symfony\Component\HttpFoundation\RequestStack
- Symfony\Component\HttpFoundation\Response
- Symfony\Component\HttpKernel\Controller\ArgumentResolverInterface
- Symfony\Component\HttpKernel\Controller\ControllerReference
- Symfony\Component\HttpKernel\Controller\ControllerResolverInterface
- Symfony\Component\HttpKernel\Event\ExceptionEvent
- Symfony\Component\HttpKernel\Fragment\InlineFragmentRenderer
- Symfony\Component\HttpKernel\HttpKernel
- Symfony\Component\HttpKernel\HttpKernelInterface
- Symfony\Component\HttpKernel\KernelEvents
- Symfony\Contracts\EventDispatcher\EventDispatcherInterface
interfaces: []
