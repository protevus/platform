name: ChoiceType
class_comment: null
dependencies:
- name: AbstractType
  type: class
  source: Symfony\Component\Form\AbstractType
- name: ChoiceListInterface
  type: class
  source: Symfony\Component\Form\ChoiceList\ChoiceListInterface
- name: ChoiceAttr
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceAttr
- name: ChoiceFieldName
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceFieldName
- name: ChoiceFilter
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceFilter
- name: ChoiceLabel
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceLabel
- name: ChoiceLoader
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceLoader
- name: ChoiceTranslationParameters
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceTranslationParameters
- name: ChoiceValue
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceValue
- name: GroupBy
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\Cache\GroupBy
- name: PreferredChoice
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\Cache\PreferredChoice
- name: CachingFactoryDecorator
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\CachingFactoryDecorator
- name: ChoiceListFactoryInterface
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\ChoiceListFactoryInterface
- name: DefaultChoiceListFactory
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\DefaultChoiceListFactory
- name: PropertyAccessDecorator
  type: class
  source: Symfony\Component\Form\ChoiceList\Factory\PropertyAccessDecorator
- name: ChoiceLoaderInterface
  type: class
  source: Symfony\Component\Form\ChoiceList\Loader\ChoiceLoaderInterface
- name: ChoiceGroupView
  type: class
  source: Symfony\Component\Form\ChoiceList\View\ChoiceGroupView
- name: ChoiceListView
  type: class
  source: Symfony\Component\Form\ChoiceList\View\ChoiceListView
- name: ChoiceView
  type: class
  source: Symfony\Component\Form\ChoiceList\View\ChoiceView
- name: PreSubmitEvent
  type: class
  source: Symfony\Component\Form\Event\PreSubmitEvent
- name: TransformationFailedException
  type: class
  source: Symfony\Component\Form\Exception\TransformationFailedException
- name: CheckboxListMapper
  type: class
  source: Symfony\Component\Form\Extension\Core\DataMapper\CheckboxListMapper
- name: RadioListMapper
  type: class
  source: Symfony\Component\Form\Extension\Core\DataMapper\RadioListMapper
- name: ChoicesToValuesTransformer
  type: class
  source: Symfony\Component\Form\Extension\Core\DataTransformer\ChoicesToValuesTransformer
- name: ChoiceToValueTransformer
  type: class
  source: Symfony\Component\Form\Extension\Core\DataTransformer\ChoiceToValueTransformer
- name: MergeCollectionListener
  type: class
  source: Symfony\Component\Form\Extension\Core\EventListener\MergeCollectionListener
- name: FormBuilderInterface
  type: class
  source: Symfony\Component\Form\FormBuilderInterface
- name: FormError
  type: class
  source: Symfony\Component\Form\FormError
- name: FormEvent
  type: class
  source: Symfony\Component\Form\FormEvent
- name: FormEvents
  type: class
  source: Symfony\Component\Form\FormEvents
- name: FormInterface
  type: class
  source: Symfony\Component\Form\FormInterface
- name: FormView
  type: class
  source: Symfony\Component\Form\FormView
- name: Options
  type: class
  source: Symfony\Component\OptionsResolver\Options
- name: OptionsResolver
  type: class
  source: Symfony\Component\OptionsResolver\OptionsResolver
- name: PropertyPath
  type: class
  source: Symfony\Component\PropertyAccess\PropertyPath
- name: TranslatorInterface
  type: class
  source: Symfony\Contracts\Translation\TranslatorInterface
properties: []
methods:
- name: __construct
  visibility: public
  parameters:
  - name: choiceListFactory
    default: 'null'
  - name: translator
    default: 'null'
  comment: null
- name: buildForm
  visibility: public
  parameters:
  - name: builder
  - name: options
  comment: null
- name: addSubForms
  visibility: private
  parameters:
  - name: builder
  - name: choiceViews
  - name: options
  comment: "# @var PreSubmitEvent $event */\n# $form = $event->getForm();\n# $data\
    \ = $event->getData();\n# \n# // Since the type always use mapper an empty array\
    \ will not be\n# // considered as empty in Form::submit(), we need to evaluate\n\
    # // empty data here so its value is submitted to sub forms\n# if (null === $data)\
    \ {\n# $emptyData = $form->getConfig()->getEmptyData();\n# $data = $emptyData\
    \ instanceof \\Closure ? $emptyData($form, $data) : $emptyData;\n# }\n# \n# //\
    \ Convert the submitted data to a string, if scalar, before\n# // casting it to\
    \ an array\n# if (!\\is_array($data)) {\n# if ($options['multiple']) {\n# throw\
    \ new TransformationFailedException('Expected an array.');\n# }\n# \n# $data =\
    \ (array) (string) $data;\n# }\n# \n# // A map from submitted values to integers\n\
    # $valueMap = array_flip($data);\n# \n# // Make a copy of the value map to determine\
    \ whether any unknown\n# // values were submitted\n# $unknownValues = $valueMap;\n\
    # \n# // Reconstruct the data as mapping from child names to values\n# $knownValues\
    \ = [];\n# \n# if ($options['expanded']) {\n# /** @var FormInterface $child */\n\
    # foreach ($form as $child) {\n# $value = $child->getConfig()->getOption('value');\n\
    # \n# // Add the value to $data with the child's name as key\n# if (isset($valueMap[$value]))\
    \ {\n# $knownValues[$child->getName()] = $value;\n# unset($unknownValues[$value]);\n\
    # continue;\n# }\n# \n# $knownValues[$child->getName()] = null;\n# }\n# } else\
    \ {\n# foreach ($choiceList->getChoicesForValues($data) as $key => $choice) {\n\
    # $knownValues[] = $data[$key];\n# unset($unknownValues[$data[$key]]);\n# }\n\
    # }\n# \n# // The empty value is always known, independent of whether a\n# //\
    \ field exists for it or not\n# unset($unknownValues['']);\n# \n# // Throw exception\
    \ if unknown values were submitted (multiple choices will be handled in a different\
    \ event listener below)\n# if (\\count($unknownValues) > 0 && !$options['multiple'])\
    \ {\n# throw new TransformationFailedException(\\sprintf('The choices \"%s\" do\
    \ not exist in the choice list.', implode('\", \"', array_keys($unknownValues))));\n\
    # }\n# \n# $event->setData($knownValues);\n# });\n# }\n# \n# if ($options['multiple'])\
    \ {\n# $messageTemplate = $options['invalid_message'] ?? 'The value {{ value }}\
    \ is not valid.';\n# $translator = $this->translator;\n# \n# $builder->addEventListener(FormEvents::POST_SUBMIT,\
    \ static function (FormEvent $event) use (&$unknownValues, $messageTemplate, $translator)\
    \ {\n# // Throw exception if unknown values were submitted\n# if (\\count($unknownValues)\
    \ > 0) {\n# $form = $event->getForm();\n# \n# $clientDataAsString = \\is_scalar($form->getViewData())\
    \ ? (string) $form->getViewData() : (\\is_array($form->getViewData()) ? implode('\"\
    , \"', array_keys($unknownValues)) : \\gettype($form->getViewData()));\n# \n#\
    \ if ($translator) {\n# $message = $translator->trans($messageTemplate, ['{{ value\
    \ }}' => $clientDataAsString], 'validators');\n# } else {\n# $message = strtr($messageTemplate,\
    \ ['{{ value }}' => $clientDataAsString]);\n# }\n# \n# $form->addError(new FormError($message,\
    \ $messageTemplate, ['{{ value }}' => $clientDataAsString], null, new TransformationFailedException(\\\
    sprintf('The choices \"%s\" do not exist in the choice list.', $clientDataAsString))));\n\
    # }\n# });\n# \n# // <select> tag with \"multiple\" option or list of checkbox\
    \ inputs\n# $builder->addViewTransformer(new ChoicesToValuesTransformer($choiceList));\n\
    # } else {\n# // <select> tag without \"multiple\" option or list of radio inputs\n\
    # $builder->addViewTransformer(new ChoiceToValueTransformer($choiceList));\n#\
    \ }\n# \n# if ($options['multiple'] && $options['by_reference']) {\n# // Make\
    \ sure the collection created during the client->norm\n# // transformation is\
    \ merged back into the original collection\n# $builder->addEventSubscriber(new\
    \ MergeCollectionListener(true, true));\n# }\n# \n# // To avoid issues when the\
    \ submitted choices are arrays (i.e. array to string conversions),\n# // we have\
    \ to ensure that all elements of the submitted choice data are NULL, strings or\
    \ ints.\n# $builder->addEventListener(FormEvents::PRE_SUBMIT, static function\
    \ (FormEvent $event) {\n# $data = $event->getData();\n# \n# if (!\\is_array($data))\
    \ {\n# return;\n# }\n# \n# foreach ($data as $v) {\n# if (null !== $v && !\\is_string($v)\
    \ && !\\is_int($v)) {\n# throw new TransformationFailedException('All choices\
    \ submitted must be NULL, strings or ints.');\n# }\n# }\n# }, 256);\n# }\n# \n\
    # public function buildView(FormView $view, FormInterface $form, array $options):\
    \ void\n# {\n# $choiceTranslationDomain = $options['choice_translation_domain'];\n\
    # if ($view->parent && null === $choiceTranslationDomain) {\n# $choiceTranslationDomain\
    \ = $view->vars['translation_domain'];\n# }\n# \n# /** @var ChoiceListInterface\
    \ $choiceList */\n# $choiceList = $form->getConfig()->getAttribute('choice_list');\n\
    # \n# /** @var ChoiceListView $choiceListView */\n# $choiceListView = $form->getConfig()->hasAttribute('choice_list_view')\n\
    # ? $form->getConfig()->getAttribute('choice_list_view')\n# : $this->createChoiceListView($choiceList,\
    \ $options);\n# \n# $view->vars = array_replace($view->vars, [\n# 'multiple' =>\
    \ $options['multiple'],\n# 'expanded' => $options['expanded'],\n# 'preferred_choices'\
    \ => $choiceListView->preferredChoices,\n# 'choices' => $choiceListView->choices,\n\
    # 'separator' => $options['separator'],\n# 'separator_html' => $options['separator_html'],\n\
    # 'placeholder' => null,\n# 'placeholder_attr' => [],\n# 'choice_translation_domain'\
    \ => $choiceTranslationDomain,\n# 'choice_translation_parameters' => $options['choice_translation_parameters'],\n\
    # ]);\n# \n# // The decision, whether a choice is selected, is potentially done\n\
    # // thousand of times during the rendering of a template. Provide a\n# // closure\
    \ here that is optimized for the value of the form, to\n# // avoid making the\
    \ type check inside the closure.\n# if ($options['multiple']) {\n# $view->vars['is_selected']\
    \ = static fn ($choice, array $values) => \\in_array($choice, $values, true);\n\
    # } else {\n# $view->vars['is_selected'] = static fn ($choice, $value) => $choice\
    \ === $value;\n# }\n# \n# // Check if the choices already contain the empty value\n\
    # $view->vars['placeholder_in_choices'] = $choiceListView->hasPlaceholder();\n\
    # \n# // Only add the empty value option if this is not the case\n# if (null !==\
    \ $options['placeholder'] && !$view->vars['placeholder_in_choices']) {\n# $view->vars['placeholder']\
    \ = $options['placeholder'];\n# $view->vars['placeholder_attr'] = $options['placeholder_attr'];\n\
    # }\n# \n# if ($options['multiple'] && !$options['expanded']) {\n# // Add \"[]\"\
    \ to the name in case a select tag with multiple options is\n# // displayed. Otherwise\
    \ only one of the selected options is sent in the\n# // POST request.\n# $view->vars['full_name']\
    \ .= '[]';\n# }\n# }\n# \n# public function finishView(FormView $view, FormInterface\
    \ $form, array $options): void\n# {\n# if ($options['expanded']) {\n# // Radio\
    \ buttons should have the same name as the parent\n# $childName = $view->vars['full_name'];\n\
    # \n# // Checkboxes should append \"[]\" to allow multiple selection\n# if ($options['multiple'])\
    \ {\n# $childName .= '[]';\n# }\n# \n# foreach ($view as $childView) {\n# $childView->vars['full_name']\
    \ = $childName;\n# }\n# }\n# }\n# \n# public function configureOptions(OptionsResolver\
    \ $resolver): void\n# {\n# $emptyData = static function (Options $options) {\n\
    # if ($options['expanded'] && !$options['multiple']) {\n# return null;\n# }\n\
    # \n# if ($options['multiple']) {\n# return [];\n# }\n# \n# return '';\n# };\n\
    # \n# $placeholderDefault = static fn (Options $options) => $options['required']\
    \ ? null : '';\n# \n# $placeholderNormalizer = static function (Options $options,\
    \ $placeholder) {\n# if ($options['multiple']) {\n# // never use an empty value\
    \ for this case\n# return null;\n# } elseif ($options['required'] && ($options['expanded']\
    \ || isset($options['attr']['size']) && $options['attr']['size'] > 1)) {\n# //\
    \ placeholder for required radio buttons or a select with size > 1 does not make\
    \ sense\n# return null;\n# } elseif (false === $placeholder) {\n# // an empty\
    \ value should be added but the user decided otherwise\n# return null;\n# } elseif\
    \ ($options['expanded'] && '' === $placeholder) {\n# // never use an empty label\
    \ for radio buttons\n# return 'None';\n# }\n# \n# // empty value has been set\
    \ explicitly\n# return $placeholder;\n# };\n# \n# $compound = static fn (Options\
    \ $options) => $options['expanded'];\n# \n# $choiceTranslationDomainNormalizer\
    \ = static function (Options $options, $choiceTranslationDomain) {\n# if (true\
    \ === $choiceTranslationDomain) {\n# return $options['translation_domain'];\n\
    # }\n# \n# return $choiceTranslationDomain;\n# };\n# \n# $resolver->setDefaults([\n\
    # 'multiple' => false,\n# 'expanded' => false,\n# 'choices' => [],\n# 'choice_filter'\
    \ => null,\n# 'choice_loader' => null,\n# 'choice_label' => null,\n# 'choice_name'\
    \ => null,\n# 'choice_value' => null,\n# 'choice_attr' => null,\n# 'choice_translation_parameters'\
    \ => [],\n# 'preferred_choices' => [],\n# 'separator' => '-------------------',\n\
    # 'separator_html' => false,\n# 'duplicate_preferred_choices' => true,\n# 'group_by'\
    \ => null,\n# 'empty_data' => $emptyData,\n# 'placeholder' => $placeholderDefault,\n\
    # 'placeholder_attr' => [],\n# 'error_bubbling' => false,\n# 'compound' => $compound,\n\
    # // The view data is always a string or an array of strings,\n# // even if the\
    \ \"data\" option is manually set to an object.\n# // See https://github.com/symfony/symfony/pull/5582\n\
    # 'data_class' => null,\n# 'choice_translation_domain' => true,\n# 'trim' => false,\n\
    # 'invalid_message' => 'The selected choice is invalid.',\n# ]);\n# \n# $resolver->setNormalizer('placeholder',\
    \ $placeholderNormalizer);\n# $resolver->setNormalizer('choice_translation_domain',\
    \ $choiceTranslationDomainNormalizer);\n# \n# $resolver->setAllowedTypes('choices',\
    \ ['null', 'array', \\Traversable::class]);\n# $resolver->setAllowedTypes('choice_translation_domain',\
    \ ['null', 'bool', 'string']);\n# $resolver->setAllowedTypes('choice_loader',\
    \ ['null', ChoiceLoaderInterface::class, ChoiceLoader::class]);\n# $resolver->setAllowedTypes('choice_filter',\
    \ ['null', 'callable', 'string', PropertyPath::class, ChoiceFilter::class]);\n\
    # $resolver->setAllowedTypes('choice_label', ['null', 'bool', 'callable', 'string',\
    \ PropertyPath::class, ChoiceLabel::class]);\n# $resolver->setAllowedTypes('choice_name',\
    \ ['null', 'callable', 'string', PropertyPath::class, ChoiceFieldName::class]);\n\
    # $resolver->setAllowedTypes('choice_value', ['null', 'callable', 'string', PropertyPath::class,\
    \ ChoiceValue::class]);\n# $resolver->setAllowedTypes('choice_attr', ['null',\
    \ 'array', 'callable', 'string', PropertyPath::class, ChoiceAttr::class]);\n#\
    \ $resolver->setAllowedTypes('choice_translation_parameters', ['null', 'array',\
    \ 'callable', ChoiceTranslationParameters::class]);\n# $resolver->setAllowedTypes('placeholder_attr',\
    \ ['array']);\n# $resolver->setAllowedTypes('preferred_choices', ['array', \\\
    Traversable::class, 'callable', 'string', PropertyPath::class, PreferredChoice::class]);\n\
    # $resolver->setAllowedTypes('separator', ['string']);\n# $resolver->setAllowedTypes('separator_html',\
    \ ['bool']);\n# $resolver->setAllowedTypes('duplicate_preferred_choices', 'bool');\n\
    # $resolver->setAllowedTypes('group_by', ['null', 'callable', 'string', PropertyPath::class,\
    \ GroupBy::class]);\n# }\n# \n# public function getBlockPrefix(): string\n# {\n\
    # return 'choice';\n# }\n# \n# /**\n# * Adds the sub fields for an expanded choice\
    \ field."
- name: addSubForm
  visibility: private
  parameters:
  - name: builder
  - name: name
  - name: choiceView
  - name: options
  comment: null
- name: createChoiceList
  visibility: private
  parameters:
  - name: options
  comment: null
- name: createChoiceListView
  visibility: private
  parameters:
  - name: choiceList
  - name: options
  comment: null
traits:
- Symfony\Component\Form\AbstractType
- Symfony\Component\Form\ChoiceList\ChoiceListInterface
- Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceAttr
- Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceFieldName
- Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceFilter
- Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceLabel
- Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceLoader
- Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceTranslationParameters
- Symfony\Component\Form\ChoiceList\Factory\Cache\ChoiceValue
- Symfony\Component\Form\ChoiceList\Factory\Cache\GroupBy
- Symfony\Component\Form\ChoiceList\Factory\Cache\PreferredChoice
- Symfony\Component\Form\ChoiceList\Factory\CachingFactoryDecorator
- Symfony\Component\Form\ChoiceList\Factory\ChoiceListFactoryInterface
- Symfony\Component\Form\ChoiceList\Factory\DefaultChoiceListFactory
- Symfony\Component\Form\ChoiceList\Factory\PropertyAccessDecorator
- Symfony\Component\Form\ChoiceList\Loader\ChoiceLoaderInterface
- Symfony\Component\Form\ChoiceList\View\ChoiceGroupView
- Symfony\Component\Form\ChoiceList\View\ChoiceListView
- Symfony\Component\Form\ChoiceList\View\ChoiceView
- Symfony\Component\Form\Event\PreSubmitEvent
- Symfony\Component\Form\Exception\TransformationFailedException
- Symfony\Component\Form\Extension\Core\DataMapper\CheckboxListMapper
- Symfony\Component\Form\Extension\Core\DataMapper\RadioListMapper
- Symfony\Component\Form\Extension\Core\DataTransformer\ChoicesToValuesTransformer
- Symfony\Component\Form\Extension\Core\DataTransformer\ChoiceToValueTransformer
- Symfony\Component\Form\Extension\Core\EventListener\MergeCollectionListener
- Symfony\Component\Form\FormBuilderInterface
- Symfony\Component\Form\FormError
- Symfony\Component\Form\FormEvent
- Symfony\Component\Form\FormEvents
- Symfony\Component\Form\FormInterface
- Symfony\Component\Form\FormView
- Symfony\Component\OptionsResolver\Options
- Symfony\Component\OptionsResolver\OptionsResolver
- Symfony\Component\PropertyAccess\PropertyPath
- Symfony\Contracts\Translation\TranslatorInterface
interfaces: []
