name: PropertyInfoLoader
class_comment: null
dependencies:
- name: PropertyAccessExtractorInterface
  type: class
  source: Symfony\Component\PropertyInfo\PropertyAccessExtractorInterface
- name: PropertyListExtractorInterface
  type: class
  source: Symfony\Component\PropertyInfo\PropertyListExtractorInterface
- name: PropertyTypeExtractorInterface
  type: class
  source: Symfony\Component\PropertyInfo\PropertyTypeExtractorInterface
- name: PropertyInfoType
  type: class
  source: Symfony\Component\PropertyInfo\Type
- name: TypeInfoType
  type: class
  source: Symfony\Component\TypeInfo\Type
- name: CollectionType
  type: class
  source: Symfony\Component\TypeInfo\Type\CollectionType
- name: IntersectionType
  type: class
  source: Symfony\Component\TypeInfo\Type\IntersectionType
- name: ObjectType
  type: class
  source: Symfony\Component\TypeInfo\Type\ObjectType
- name: UnionType
  type: class
  source: Symfony\Component\TypeInfo\Type\UnionType
- name: TypeIdentifier
  type: class
  source: Symfony\Component\TypeInfo\TypeIdentifier
- name: All
  type: class
  source: Symfony\Component\Validator\Constraints\All
- name: NotBlank
  type: class
  source: Symfony\Component\Validator\Constraints\NotBlank
- name: NotNull
  type: class
  source: Symfony\Component\Validator\Constraints\NotNull
- name: Type
  type: class
  source: Symfony\Component\Validator\Constraints\Type
- name: AutoMappingStrategy
  type: class
  source: Symfony\Component\Validator\Mapping\AutoMappingStrategy
- name: ClassMetadata
  type: class
  source: Symfony\Component\Validator\Mapping\ClassMetadata
- name: AutoMappingTrait
  type: class
  source: AutoMappingTrait
properties: []
methods:
- name: getPropertyTypes
  visibility: private
  parameters:
  - name: className
  - name: property
  comment: "# * Guesses and loads the appropriate constraints using PropertyInfo.\n\
    # *\n# * @author K\xE9vin Dunglas <dunglas@gmail.com>\n# */\n# final class PropertyInfoLoader\
    \ implements LoaderInterface\n# {\n# use AutoMappingTrait;\n# \n# public function\
    \ __construct(\n# private PropertyListExtractorInterface $listExtractor,\n# private\
    \ PropertyTypeExtractorInterface $typeExtractor,\n# private PropertyAccessExtractorInterface\
    \ $accessExtractor,\n# private ?string $classValidatorRegexp = null,\n# ) {\n\
    # }\n# \n# public function loadClassMetadata(ClassMetadata $metadata): bool\n\
    # {\n# $className = $metadata->getClassName();\n# if (!$properties = $this->listExtractor->getProperties($className))\
    \ {\n# return false;\n# }\n# \n# $loaded = false;\n# $enabledForClass = $this->isAutoMappingEnabledForClass($metadata,\
    \ $this->classValidatorRegexp);\n# foreach ($properties as $property) {\n# if\
    \ (false === $this->accessExtractor->isWritable($className, $property)) {\n# continue;\n\
    # }\n# \n# if (!property_exists($className, $property)) {\n# continue;\n# }\n\
    # \n# $types = $this->getPropertyTypes($className, $property);\n# if (null ===\
    \ $types) {\n# continue;\n# }\n# \n# $enabledForProperty = $enabledForClass;\n\
    # $hasTypeConstraint = false;\n# $hasNotNullConstraint = false;\n# $hasNotBlankConstraint\
    \ = false;\n# $allConstraint = null;\n# foreach ($metadata->getPropertyMetadata($property)\
    \ as $propertyMetadata) {\n# // Enabling or disabling auto-mapping explicitly\
    \ always takes precedence\n# if (AutoMappingStrategy::DISABLED === $propertyMetadata->getAutoMappingStrategy())\
    \ {\n# continue 2;\n# }\n# \n# if (AutoMappingStrategy::ENABLED === $propertyMetadata->getAutoMappingStrategy())\
    \ {\n# $enabledForProperty = true;\n# }\n# \n# foreach ($propertyMetadata->getConstraints()\
    \ as $constraint) {\n# if ($constraint instanceof Type) {\n# $hasTypeConstraint\
    \ = true;\n# } elseif ($constraint instanceof NotNull) {\n# $hasNotNullConstraint\
    \ = true;\n# } elseif ($constraint instanceof NotBlank) {\n# $hasNotBlankConstraint\
    \ = true;\n# } elseif ($constraint instanceof All) {\n# $allConstraint = $constraint;\n\
    # }\n# }\n# }\n# \n# if (!$enabledForProperty) {\n# continue;\n# }\n# \n# $loaded\
    \ = true;\n# \n# // BC layer for PropertyTypeExtractorInterface::getTypes().\n\
    # // Can be removed as soon as PropertyTypeExtractorInterface::getTypes() is removed\
    \ (8.0).\n# if (\\is_array($types)) {\n# $builtinTypes = [];\n# $nullable = false;\n\
    # $scalar = true;\n# \n# foreach ($types as $type) {\n# $builtinTypes[] = $type->getBuiltinType();\n\
    # \n# if ($scalar && !\\in_array($type->getBuiltinType(), ['int', 'float', 'string',\
    \ 'bool'], true)) {\n# $scalar = false;\n# }\n# \n# if (!$nullable && $type->isNullable())\
    \ {\n# $nullable = true;\n# }\n# }\n# \n# if (!$hasTypeConstraint) {\n# if (1\
    \ === \\count($builtinTypes)) {\n# if ($types[0]->isCollection() && \\count($collectionValueType\
    \ = $types[0]->getCollectionValueTypes()) > 0) {\n# [$collectionValueType] = $collectionValueType;\n\
    # $this->handleAllConstraintLegacy($property, $allConstraint, $collectionValueType,\
    \ $metadata);\n# }\n# \n# $metadata->addPropertyConstraint($property, $this->getTypeConstraintLegacy($builtinTypes[0],\
    \ $types[0]));\n# } elseif ($scalar) {\n# $metadata->addPropertyConstraint($property,\
    \ new Type(['type' => 'scalar']));\n# }\n# }\n# \n# if (!$nullable && !$hasNotBlankConstraint\
    \ && !$hasNotNullConstraint) {\n# $metadata->addPropertyConstraint($property,\
    \ new NotNull());\n# }\n# } else {\n# if ($hasTypeConstraint) {\n# continue;\n\
    # }\n# \n# $type = $types;\n# $nullable = false;\n# \n# if ($type instanceof UnionType\
    \ && $type->isNullable()) {\n# $nullable = true;\n# $type = $type->asNonNullable();\n\
    # }\n# \n# if ($type instanceof CollectionType) {\n# $this->handleAllConstraint($property,\
    \ $allConstraint, $type->getCollectionValueType(), $metadata);\n# }\n# \n# if\
    \ (null !== $typeConstraint = $this->getTypeConstraint($type)) {\n# $metadata->addPropertyConstraint($property,\
    \ $typeConstraint);\n# }\n# \n# if (!$nullable && !$hasNotBlankConstraint && !$hasNotNullConstraint)\
    \ {\n# $metadata->addPropertyConstraint($property, new NotNull());\n# }\n# }\n\
    # }\n# \n# return $loaded;\n# }\n# \n# /**\n# * BC layer for PropertyTypeExtractorInterface::getTypes().\n\
    # * Can be removed as soon as PropertyTypeExtractorInterface::getTypes() is removed\
    \ (8.0).\n# *\n# * @return TypeInfoType|list<PropertyInfoType>|null"
- name: getTypeConstraintLegacy
  visibility: private
  parameters:
  - name: builtinType
  - name: type
  comment: '# * BC layer for PropertyTypeExtractorInterface::getTypes().

    # * Can be removed as soon as PropertyTypeExtractorInterface::getTypes() is removed
    (8.0).'
- name: getTypeConstraint
  visibility: private
  parameters:
  - name: type
  comment: null
- name: handleAllConstraint
  visibility: private
  parameters:
  - name: property
  - name: allConstraint
  - name: type
  - name: metadata
  comment: null
- name: handleAllConstraintLegacy
  visibility: private
  parameters:
  - name: property
  - name: allConstraint
  - name: propertyInfoType
  - name: metadata
  comment: '# * BC layer for PropertyTypeExtractorInterface::getTypes().

    # * Can be removed as soon as PropertyTypeExtractorInterface::getTypes() is removed
    (8.0).'
traits:
- Symfony\Component\PropertyInfo\PropertyAccessExtractorInterface
- Symfony\Component\PropertyInfo\PropertyListExtractorInterface
- Symfony\Component\PropertyInfo\PropertyTypeExtractorInterface
- Symfony\Component\TypeInfo\Type\CollectionType
- Symfony\Component\TypeInfo\Type\IntersectionType
- Symfony\Component\TypeInfo\Type\ObjectType
- Symfony\Component\TypeInfo\Type\UnionType
- Symfony\Component\TypeInfo\TypeIdentifier
- Symfony\Component\Validator\Constraints\All
- Symfony\Component\Validator\Constraints\NotBlank
- Symfony\Component\Validator\Constraints\NotNull
- Symfony\Component\Validator\Constraints\Type
- Symfony\Component\Validator\Mapping\AutoMappingStrategy
- Symfony\Component\Validator\Mapping\ClassMetadata
- AutoMappingTrait
interfaces:
- LoaderInterface
