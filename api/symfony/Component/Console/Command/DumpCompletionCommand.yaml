name: DumpCompletionCommand
class_comment: null
dependencies:
- name: AsCommand
  type: class
  source: Symfony\Component\Console\Attribute\AsCommand
- name: InputArgument
  type: class
  source: Symfony\Component\Console\Input\InputArgument
- name: InputInterface
  type: class
  source: Symfony\Component\Console\Input\InputInterface
- name: InputOption
  type: class
  source: Symfony\Component\Console\Input\InputOption
- name: ConsoleOutputInterface
  type: class
  source: Symfony\Component\Console\Output\ConsoleOutputInterface
- name: OutputInterface
  type: class
  source: Symfony\Component\Console\Output\OutputInterface
- name: Process
  type: class
  source: Symfony\Component\Process\Process
properties: []
methods:
- name: getSupportedShells
  visibility: private
  parameters: []
  comment: "# * Dumps the completion script for the current shell.\n# *\n# * @author\
    \ Wouter de Jong <wouter@wouterj.nl>\n# */\n# #[AsCommand(name: 'completion',\
    \ description: 'Dump the shell completion script')]\n# final class DumpCompletionCommand\
    \ extends Command\n# {\n# private array $supportedShells;\n# \n# protected function\
    \ configure(): void\n# {\n# $fullCommand = $_SERVER['PHP_SELF'];\n# $commandName\
    \ = basename($fullCommand);\n# $fullCommand = @realpath($fullCommand) ?: $fullCommand;\n\
    # \n# $shell = $this->guessShell();\n# [$rcFile, $completionFile] = match ($shell)\
    \ {\n# 'fish' => ['~/.config/fish/config.fish', \"/etc/fish/completions/$commandName.fish\"\
    ],\n# 'zsh' => ['~/.zshrc', '$fpath[1]/_'.$commandName],\n# default => ['~/.bashrc',\
    \ \"/etc/bash_completion.d/$commandName\"],\n# };\n# \n# $supportedShells = implode(',\
    \ ', $this->getSupportedShells());\n# \n# $this\n# ->setHelp(<<<EOH\n# The <info>%command.name%</>\
    \ command dumps the shell completion script required\n# to use shell autocompletion\
    \ (currently, {$supportedShells} completion are supported).\n# \n# <comment>Static\
    \ installation\n# -------------------</>\n# \n# Dump the script to a global completion\
    \ file and restart your shell:\n# \n# <info>%command.full_name% {$shell} | sudo\
    \ tee {$completionFile}</>\n# \n# Or dump the script to a local file and source\
    \ it:\n# \n# <info>%command.full_name% {$shell} > completion.sh</>\n# \n# <comment>#\
    \ source the file whenever you use the project</>\n# <info>source completion.sh</>\n\
    # \n# <comment># or add this line at the end of your \"{$rcFile}\" file:</>\n\
    # <info>source /path/to/completion.sh</>\n# \n# <comment>Dynamic installation\n\
    # --------------------</>\n# \n# Add this to the end of your shell configuration\
    \ file (e.g. <info>\"{$rcFile}\"</>):\n# \n# <info>eval \"$({$fullCommand} completion\
    \ {$shell})\"</>\n# EOH\n# )\n# ->addArgument('shell', InputArgument::OPTIONAL,\
    \ 'The shell type (e.g. \"bash\"), the value of the \"$SHELL\" env var will be\
    \ used if this is not given', null, $this->getSupportedShells(...))\n# ->addOption('debug',\
    \ null, InputOption::VALUE_NONE, 'Tail the completion debug log')\n# ;\n# }\n\
    # \n# protected function execute(InputInterface $input, OutputInterface $output):\
    \ int\n# {\n# $commandName = basename($_SERVER['argv'][0]);\n# \n# if ($input->getOption('debug'))\
    \ {\n# $this->tailDebugLog($commandName, $output);\n# \n# return 0;\n# }\n# \n\
    # $shell = $input->getArgument('shell') ?? self::guessShell();\n# $completionFile\
    \ = __DIR__.'/../Resources/completion.'.$shell;\n# if (!file_exists($completionFile))\
    \ {\n# $supportedShells = $this->getSupportedShells();\n# \n# if ($output instanceof\
    \ ConsoleOutputInterface) {\n# $output = $output->getErrorOutput();\n# }\n# if\
    \ ($shell) {\n# $output->writeln(\\sprintf('<error>Detected shell \"%s\", which\
    \ is not supported by Symfony shell completion (supported shells: \"%s\").</>',\
    \ $shell, implode('\", \"', $supportedShells)));\n# } else {\n# $output->writeln(\\\
    sprintf('<error>Shell not detected, Symfony shell completion only supports \"\
    %s\").</>', implode('\", \"', $supportedShells)));\n# }\n# \n# return 2;\n# }\n\
    # \n# $output->write(str_replace(['{{ COMMAND_NAME }}', '{{ VERSION }}'], [$commandName,\
    \ CompleteCommand::COMPLETION_API_VERSION], file_get_contents($completionFile)));\n\
    # \n# return 0;\n# }\n# \n# private static function guessShell(): string\n# {\n\
    # return basename($_SERVER['SHELL'] ?? '');\n# }\n# \n# private function tailDebugLog(string\
    \ $commandName, OutputInterface $output): void\n# {\n# $debugFile = sys_get_temp_dir().'/sf_'.$commandName.'.log';\n\
    # if (!file_exists($debugFile)) {\n# touch($debugFile);\n# }\n# $process = new\
    \ Process(['tail', '-f', $debugFile], null, null, null, 0);\n# $process->run(function\
    \ (string $type, string $line) use ($output): void {\n# $output->write($line);\n\
    # });\n# }\n# \n# /**\n# * @return string[]"
traits:
- Symfony\Component\Console\Attribute\AsCommand
- Symfony\Component\Console\Input\InputArgument
- Symfony\Component\Console\Input\InputInterface
- Symfony\Component\Console\Input\InputOption
- Symfony\Component\Console\Output\ConsoleOutputInterface
- Symfony\Component\Console\Output\OutputInterface
- Symfony\Component\Process\Process
interfaces: []
