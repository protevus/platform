-- Firebird initialization script for development environment

-- Create development database
CREATE DATABASE 'localhost:development.fdb'
    USER 'SYSDBA' PASSWORD 'masterkey'
    PAGE_SIZE 16384
    DEFAULT CHARACTER SET UTF8
    COLLATION UTF8;

CONNECT 'localhost:development.fdb'
    USER 'SYSDBA' PASSWORD 'masterkey';

-- Create monitoring tables
CREATE TABLE MON_CONNECTIONS (
    CONNECTION_ID INTEGER NOT NULL,
    USER_NAME VARCHAR(31),
    REMOTE_ADDRESS VARCHAR(255),
    REMOTE_PROCESS VARCHAR(255),
    CONNECTION_TIME TIMESTAMP,
    TRANSACTION_COUNT INTEGER,
    PRIMARY KEY (CONNECTION_ID)
);

CREATE TABLE MON_TRANSACTIONS (
    TRANSACTION_ID INTEGER NOT NULL,
    CONNECTION_ID INTEGER,
    TRANSACTION_START TIMESTAMP,
    ISOLATION_MODE VARCHAR(20),
    LOCK_TIMEOUT INTEGER,
    READ_ONLY BOOLEAN,
    PRIMARY KEY (TRANSACTION_ID)
);

CREATE TABLE MON_STATEMENTS (
    STATEMENT_ID INTEGER NOT NULL,
    TRANSACTION_ID INTEGER,
    SQL_TEXT BLOB SUB_TYPE TEXT,
    STATEMENT_START TIMESTAMP,
    STATEMENT_END TIMESTAMP,
    ROW_READS BIGINT,
    ROW_WRITES BIGINT,
    PRIMARY KEY (STATEMENT_ID)
);

-- Create monitoring procedures
SET TERM ^ ;

CREATE OR ALTER PROCEDURE MONITOR_CONNECTIONS
RETURNS (
    CONNECTION_ID INTEGER,
    USER_NAME VARCHAR(31),
    REMOTE_ADDRESS VARCHAR(255),
    REMOTE_PROCESS VARCHAR(255),
    CONNECTION_TIME TIMESTAMP,
    TRANSACTION_COUNT INTEGER
)
AS
BEGIN
    FOR SELECT
        MON$ATTACHMENT_ID,
        MON$USER,
        MON$REMOTE_ADDRESS,
        MON$REMOTE_PROCESS,
        MON$TIMESTAMP,
        MON$TRANSACTION_COUNT
    FROM MON$ATTACHMENTS
    WHERE MON$ATTACHMENT_ID <> CURRENT_CONNECTION
    INTO
        CONNECTION_ID,
        USER_NAME,
        REMOTE_ADDRESS,
        REMOTE_PROCESS,
        CONNECTION_TIME,
        TRANSACTION_COUNT
    DO
        SUSPEND;
END^

CREATE OR ALTER PROCEDURE MONITOR_TRANSACTIONS
RETURNS (
    TRANSACTION_ID INTEGER,
    CONNECTION_ID INTEGER,
    TRANSACTION_START TIMESTAMP,
    ISOLATION_MODE VARCHAR(20),
    LOCK_TIMEOUT INTEGER,
    READ_ONLY BOOLEAN
)
AS
BEGIN
    FOR SELECT
        MON$TRANSACTION_ID,
        MON$ATTACHMENT_ID,
        MON$TIMESTAMP,
        MON$ISOLATION_MODE,
        MON$LOCK_TIMEOUT,
        MON$READ_ONLY
    FROM MON$TRANSACTIONS
    INTO
        TRANSACTION_ID,
        CONNECTION_ID,
        TRANSACTION_START,
        ISOLATION_MODE,
        LOCK_TIMEOUT,
        READ_ONLY
    DO
        SUSPEND;
END^

CREATE OR ALTER PROCEDURE MONITOR_STATEMENTS
RETURNS (
    STATEMENT_ID INTEGER,
    TRANSACTION_ID INTEGER,
    SQL_TEXT BLOB SUB_TYPE TEXT,
    STATEMENT_START TIMESTAMP,
    ROW_READS BIGINT,
    ROW_WRITES BIGINT
)
AS
BEGIN
    FOR SELECT
        MON$STATEMENT_ID,
        MON$TRANSACTION_ID,
        MON$SQL_TEXT,
        MON$TIMESTAMP,
        MON$STAT_ID,
        MON$STAT_GROUP
    FROM MON$STATEMENTS
    WHERE MON$ATTACHMENT_ID <> CURRENT_CONNECTION
    INTO
        STATEMENT_ID,
        TRANSACTION_ID,
        SQL_TEXT,
        STATEMENT_START,
        ROW_READS,
        ROW_WRITES
    DO
        SUSPEND;
END^

-- Create utility procedures
CREATE OR ALTER PROCEDURE ANALYZE_TABLE (
    TABLE_NAME VARCHAR(31)
)
RETURNS (
    FIELD_NAME VARCHAR(31),
    FIELD_TYPE VARCHAR(31),
    FIELD_LENGTH INTEGER,
    FIELD_SCALE INTEGER,
    IS_NULLABLE BOOLEAN,
    DEFAULT_VALUE BLOB SUB_TYPE TEXT
)
AS
BEGIN
    FOR SELECT
        RF.RDB$FIELD_NAME,
        F.RDB$FIELD_TYPE,
        F.RDB$FIELD_LENGTH,
        F.RDB$FIELD_SCALE,
        CASE WHEN RF.RDB$NULL_FLAG = 1 THEN FALSE ELSE TRUE END,
        RF.RDB$DEFAULT_SOURCE
    FROM RDB$RELATION_FIELDS RF
    JOIN RDB$FIELDS F ON RF.RDB$FIELD_SOURCE = F.RDB$FIELD_NAME
    WHERE RF.RDB$RELATION_NAME = :TABLE_NAME
    ORDER BY RF.RDB$FIELD_POSITION
    INTO
        FIELD_NAME,
        FIELD_TYPE,
        FIELD_LENGTH,
        FIELD_SCALE,
        IS_NULLABLE,
        DEFAULT_VALUE
    DO
        SUSPEND;
END^

CREATE OR ALTER PROCEDURE ANALYZE_INDEXES (
    TABLE_NAME VARCHAR(31)
)
RETURNS (
    INDEX_NAME VARCHAR(31),
    FIELD_NAME VARCHAR(31),
    IS_UNIQUE BOOLEAN,
    IS_ASCENDING BOOLEAN
)
AS
BEGIN
    FOR SELECT
        I.RDB$INDEX_NAME,
        ISG.RDB$FIELD_NAME,
        CASE WHEN I.RDB$UNIQUE_FLAG = 1 THEN TRUE ELSE FALSE END,
        CASE WHEN ISG.RDB$FIELD_NAME IS NULL THEN TRUE ELSE FALSE END
    FROM RDB$INDICES I
    LEFT JOIN RDB$INDEX_SEGMENTS ISG ON I.RDB$INDEX_NAME = ISG.RDB$INDEX_NAME
    WHERE I.RDB$RELATION_NAME = :TABLE_NAME
    ORDER BY I.RDB$INDEX_NAME, ISG.RDB$FIELD_POSITION
    INTO
        INDEX_NAME,
        FIELD_NAME,
        IS_UNIQUE,
        IS_ASCENDING
    DO
        SUSPEND;
END^

CREATE OR ALTER PROCEDURE ANALYZE_DEPENDENCIES (
    OBJECT_NAME VARCHAR(31)
)
RETURNS (
    DEPENDENT_NAME VARCHAR(31),
    DEPENDENT_TYPE VARCHAR(31),
    FIELD_NAME VARCHAR(31)
)
AS
BEGIN
    FOR SELECT
        D.RDB$DEPENDENT_NAME,
        D.RDB$DEPENDENT_TYPE,
        D.RDB$FIELD_NAME
    FROM RDB$DEPENDENCIES D
    WHERE D.RDB$DEPENDED_ON_NAME = :OBJECT_NAME
    ORDER BY D.RDB$DEPENDENT_NAME
    INTO
        DEPENDENT_NAME,
        DEPENDENT_TYPE,
        FIELD_NAME
    DO
        SUSPEND;
END^

SET TERM ; ^

-- Create development user if specified
EXECUTE BLOCK AS
BEGIN
    IF (EXISTS(SELECT 1 FROM RDB$DATABASE WHERE RDB$RELATION_NAME = 'DEV_DB_USER')) THEN
    BEGIN
        EXECUTE STATEMENT 'CREATE USER ' || :DEV_DB_USER ||
            ' PASSWORD ''' || :DEV_DB_PASSWORD || '''';
        
        EXECUTE STATEMENT 'GRANT RDB$ADMIN TO ' || :DEV_DB_USER;
    END
END

-- Create test database if enabled
EXECUTE BLOCK AS
BEGIN
    IF (:CREATE_TEST_DB = TRUE) THEN
    BEGIN
        EXECUTE STATEMENT 'CREATE DATABASE ''localhost:test.fdb''
            USER ''SYSDBA'' PASSWORD ''masterkey''
            PAGE_SIZE 16384
            DEFAULT CHARACTER SET UTF8
            COLLATION UTF8';
    END
END

COMMIT;

-- Create sample tables for development
CREATE TABLE CUSTOMERS (
    ID INTEGER NOT NULL PRIMARY KEY,
    NAME VARCHAR(100),
    EMAIL VARCHAR(100),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ORDERS (
    ID INTEGER NOT NULL PRIMARY KEY,
    CUSTOMER_ID INTEGER REFERENCES CUSTOMERS(ID),
    ORDER_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    TOTAL_AMOUNT DECIMAL(15,2)
);

CREATE TABLE ORDER_ITEMS (
    ID INTEGER NOT NULL PRIMARY KEY,
    ORDER_ID INTEGER REFERENCES ORDERS(ID),
    PRODUCT_NAME VARCHAR(100),
    QUANTITY INTEGER,
    PRICE DECIMAL(15,2)
);

-- Create indexes
CREATE INDEX IDX_CUSTOMERS_EMAIL ON CUSTOMERS(EMAIL);
CREATE INDEX IDX_ORDERS_CUSTOMER ON ORDERS(CUSTOMER_ID);
CREATE INDEX IDX_ORDER_ITEMS_ORDER ON ORDER_ITEMS(ORDER_ID);

COMMIT;
